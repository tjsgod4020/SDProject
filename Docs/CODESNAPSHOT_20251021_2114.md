# Code Snapshot - 2025-10-21 21:14:49
Commit: f8e3aa9

## Assets\SDProject\Scripts\Core\Domain\SD.Core.Domain.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Core\Domain\SD.Core.Domain.asmdef.Extension)
{
  "name": "SD.Core.Domain",
  "references": [],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Core\Infrastructure\SD.Core.Infrastructure.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Core\Infrastructure\SD.Core.Infrastructure.asmdef.Extension)
{
  "name": "SD.Core.Infrastructure",
  "references": [
    "SD.Core.Domain"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Core\Presentation\SD.Core.Presentation.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Core\Presentation\SD.Core.Presentation.asmdef.Extension)
{
  "name": "SD.Core.Presentation",
  "references": [
    "SD.Core.Domain",
    "SD.Core.Infrastructure",
    "Unity.TextMeshPro"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Core\Tests\SD.Tests.EditMode.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Core\Tests\SD.Tests.EditMode.asmdef.Extension)
{
  "name": "SD.Tests.EditMode",
  "references": [
    "SD.Core.Domain",
    "SD.Core.Infrastructure"
  ],
  "includePlatforms": [
    "Editor"
  ],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false,
  "optionalUnityReferences": [
    "TestAssemblies"
  ]
}

```

## Assets\SDProject\Scripts\DataTable\Editor\DataTableConfigAutoSync.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Editor\DataTableConfigAutoSync.cs.Extension)
#if UNITY_EDITOR
using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace SD.DataTable.Editor
{
    /// CSV 폴더를 스캔하여 모든 DataTableConfig의 _tables 배열을 동기화하고
    /// RowTypeName을 AssemblyQualifiedName으로 자동 채운다.
    /// - 우선순위: [DataTableId("Id")] > 관습(Id / IdRow / IdModel / IdDataModel)
    /// - 유일성 보장: 후보가 0개/2개 이상이면 채우지 않고 경고만 남긴다.
    /// - 메뉴 제공: Auto Sync 토글 / CSV 폴더 지정 / 전체 동기화 실행
    public sealed class DataTableConfigAutoSync : AssetPostprocessor
    {
        private const string CsvFolderDefault = "Assets/SDProject/DataTables/Csv";
        private const string PrefKeyAutoSync = "SD.DataTable.AutoSync.Enabled";
        private const string PrefKeyCsvFolder = "SD.DataTable.CsvFolder";

        private static bool _isSyncInProgress;

        [InitializeOnLoadMethod]
        private static void Init()
        {
            if (!EditorPrefs.HasKey(PrefKeyAutoSync))
                EditorPrefs.SetBool(PrefKeyAutoSync, true);
            if (!EditorPrefs.HasKey(PrefKeyCsvFolder))
                EditorPrefs.SetString(PrefKeyCsvFolder, CsvFolderDefault);
        }

        [MenuItem("Tools/DataTables/Auto Sync Config", priority = 10)]
        private static void ToggleAutoSync()
        {
            bool now = EditorPrefs.GetBool(PrefKeyAutoSync, true);
            EditorPrefs.SetBool(PrefKeyAutoSync, !now);
            Debug.Log($"[DataTable] Auto Sync: {(!now ? "ON" : "OFF")}");
        }

        [MenuItem("Tools/DataTables/Auto Sync Config", true)]
        private static bool ToggleAutoSyncValidate()
        {
            Menu.SetChecked("Tools/DataTables/Auto Sync Config", EditorPrefs.GetBool(PrefKeyAutoSync, true));
            return true;
        }

        [MenuItem("Tools/DataTables/Set CSV Folder...", priority = 11)]
        private static void SetCsvFolder()
        {
            var current = EditorPrefs.GetString(PrefKeyCsvFolder, CsvFolderDefault);
            var sel = EditorUtility.OpenFolderPanel("Select CSV Folder (under Assets)", current, "");
            if (string.IsNullOrEmpty(sel)) return;

            var proj = Application.dataPath.Substring(0, Application.dataPath.Length - "Assets".Length);
            if (!sel.StartsWith(proj))
            {
                Debug.LogError("선택한 폴더는 프로젝트 Assets 내부여야 합니다.");
                return;
            }

            var rel = sel.Substring(proj.Length).Replace('\\', '/');
            if (!rel.StartsWith("Assets/")) rel = "Assets/" + rel.TrimStart('/');
            if (!AssetDatabase.IsValidFolder(rel))
            {
                Debug.LogError($"유효하지 않은 폴더: {rel}");
                return;
            }

            EditorPrefs.SetString(PrefKeyCsvFolder, rel);
            Debug.Log($"[DataTable] CSV Folder: {rel}");
        }

        [MenuItem("Tools/DataTables/Sync All Configs Now", priority = 12)]
        private static void SyncAllNow()
        {
            var csvFolder = EditorPrefs.GetString(PrefKeyCsvFolder, CsvFolderDefault);
            SyncAllConfigs(csvFolder);
        }

        private static void OnPostprocessAllAssets(string[] imported, string[] deleted, string[] movedTo, string[] movedFrom)
        {
            if (!EditorPrefs.GetBool(PrefKeyAutoSync, true)) return;
            if (_isSyncInProgress) return;

            string csvFolder = EditorPrefs.GetString(PrefKeyCsvFolder, CsvFolderDefault);
            bool relevant =
                imported.Any(p => IsCsvUnder(p, csvFolder)) ||
                movedTo.Any(p => IsCsvUnder(p, csvFolder)) ||
                deleted.Any(p => IsCsvUnder(p, csvFolder)) ||
                movedFrom.Any(p => IsCsvUnder(p, csvFolder));

            if (relevant) SyncAllConfigs(csvFolder);
        }

        static bool IsCsvUnder(string path, string root)
            => path.StartsWith(root, StringComparison.OrdinalIgnoreCase) &&
               path.EndsWith(".csv", StringComparison.OrdinalIgnoreCase);

        private static void SyncAllConfigs(string csvFolder)
        {
            if (_isSyncInProgress) return;
            _isSyncInProgress = true;

            try
            {
                if (!AssetDatabase.IsValidFolder(csvFolder))
                {
                    Debug.LogWarning($"[DataTable] CSV folder missing: {csvFolder}");
                    return;
                }

                // 1) 모든 DataTableConfig
                var cfgGuids = AssetDatabase.FindAssets("t:DataTableConfig");
                var cfgs = cfgGuids
                    .Select(g => AssetDatabase.LoadAssetAtPath<UnityEngine.ScriptableObject>(AssetDatabase.GUIDToAssetPath(g)))
                    .Where(c => c != null)
                    .ToList();
                if (cfgs.Count == 0) return;

                // 2) CSV 수집
                var csvGuids = AssetDatabase.FindAssets("t:TextAsset", new[] { csvFolder });
                var csvPaths = csvGuids
                    .Select(AssetDatabase.GUIDToAssetPath)
                    .Where(p => p.EndsWith(".csv", StringComparison.OrdinalIgnoreCase))
                    .Distinct(StringComparer.OrdinalIgnoreCase)
                    .OrderBy(p => p, StringComparer.OrdinalIgnoreCase)
                    .ToList();

                // 3) 타입 인덱스
                BuildTypeIndexes(out var byAttr, out var byName, out var byNameRow);

                // 4) 적용
                int totalEntries = 0, filledTypes = 0;
                AssetDatabase.StartAssetEditing();
                try
                {
                    foreach (var cfg in cfgs)
                        totalEntries += ApplyToConfig(cfg, csvPaths, byAttr, byName, byNameRow, ref filledTypes);
                }
                finally
                {
                    AssetDatabase.StopAssetEditing();
                    AssetDatabase.SaveAssets();
                    AssetDatabase.Refresh();
                }

                Debug.Log($"[DataTable] Auto Sync complete → Configs: {cfgs.Count}, Tables: {totalEntries}, Typed: {filledTypes}");
            }
            finally
            {
                _isSyncInProgress = false;
            }
        }

        private static int ApplyToConfig(
            UnityEngine.ScriptableObject cfg,
            List<string> csvPaths,
            Dictionary<string, Type> byAttr,
            Dictionary<string, Type> byName,
            Dictionary<string, Type> byNameRow,
            ref int filledTypes)
        {
            // DataTableConfig 구조를 SerializedObject로 접근:
            // - 리스트 필드명: "_tables"
            // - 각 요소: "Id"(string) / "Csv"(TextAsset) / "RowTypeName"(string)
            var so = new SerializedObject(cfg);
            var listProp = so.FindProperty("_tables");
            if (listProp == null || !listProp.isArray)
            {
                Debug.LogWarning($"[DataTable] {_nameof(cfg)} 에 '_tables' 배열이 없습니다. 스킵.");
                return 0;
            }

            listProp.ClearArray();
            int i = 0, localFilled = 0;

            foreach (var p in csvPaths)
            {
                var csv = AssetDatabase.LoadAssetAtPath<TextAsset>(p);
                var id = Path.GetFileNameWithoutExtension(p);

                var rowType = ResolveRowTypeStrict(id, byAttr, byName, byNameRow, out var reason);

                listProp.InsertArrayElementAtIndex(i);
                var elem = listProp.GetArrayElementAtIndex(i++);
                elem.FindPropertyRelative("Id")?.SetString(id);
                elem.FindPropertyRelative("Csv")?.SetObject(csv);

                if (rowType != null)
                {
                    elem.FindPropertyRelative("RowTypeName")?.SetString(rowType.AssemblyQualifiedName);
                    localFilled++;
                    if (reason != "attribute")
                        Debug.Log($"[DataTable] RowTypeName set by convention: Id='{id}' → {rowType.FullName}");
                }
                else
                {
                    elem.FindPropertyRelative("RowTypeName")?.SetString(string.Empty);
                    var msg = reason == "no-match"
                        ? $"No type found for Id '{id}'. Row 타입에 [SD.DataTable.DataTableId(\"{id}\")] 특성을 부여(권장)하거나, 클래스명을 '{id}', '{id}Row', '{id}Model', '{id}DataModel' 중 하나로 맞추세요."
                        : $"Multiple candidate types for Id '{id}' → {reason}. 특성 [SD.DataTable.DataTableId(\"{id}\")]으로 명시해 주세요.";
                    Debug.LogWarning($"[DataTable] {msg} (Config: {cfg.name})");
                }
            }

            so.ApplyModifiedProperties();
            EditorUtility.SetDirty(cfg);
            filledTypes += localFilled;
            return i;

            static string _nameof(UnityEngine.Object o) => o != null ? o.name : "(null)";
        }

        private static Type ResolveRowTypeStrict(
            string id,
            Dictionary<string, Type> byAttr,
            Dictionary<string, Type> byName,
            Dictionary<string, Type> byNameRow,
            out string reason)
        {
            // 1) 특성 우선
            if (byAttr.TryGetValue(id, out var viaAttr)) { reason = "attribute"; return viaAttr; }

            // 2) 관습 후보 수집
            var candidates = new List<Type>();
            if (byName.TryGetValue(id, out var t0)) candidates.Add(t0);
            if (byNameRow.TryGetValue(id, out var t1)) candidates.Add(t1);
            if (byName.TryGetValue(id + "Model", out var t2)) candidates.Add(t2);
            if (byName.TryGetValue(id + "DataModel", out var t3)) candidates.Add(t3);

            // 유일성 판단
            var distinct = candidates.Distinct().ToList();
            if (distinct.Count == 1) { reason = "convention"; return distinct[0]; }

            if (distinct.Count == 0) reason = "no-match";
            else reason = "ambiguous: " + string.Join(", ", distinct.Select(x => x.FullName));
            return null;
        }

        private static void BuildTypeIndexes(
            out Dictionary<string, Type> byAttribute,
            out Dictionary<string, Type> byName,
            out Dictionary<string, Type> byNameRow)
        {
            byAttribute = new(StringComparer.OrdinalIgnoreCase);
            byName = new(StringComparer.OrdinalIgnoreCase);
            byNameRow = new(StringComparer.OrdinalIgnoreCase);

            foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())
            {
                var n = asm.GetName().Name;
                if (n.StartsWith("Unity") || n.StartsWith("System") || n.StartsWith("mscorlib") || n.StartsWith("netstandard"))
                    continue;

                Type[] types;
                try { types = asm.GetTypes(); } catch { continue; }

                foreach (var t in types)
                {
                    if (!t.IsClass || t.IsAbstract) continue;

                    // [DataTableId("...")]
                    var attr = t.GetCustomAttribute<SD.DataTable.DataTableIdAttribute>();
                    if (attr != null && !string.IsNullOrWhiteSpace(attr.Id))
                        byAttribute[attr.Id] = t;

                    // 클래스명 == "Id"
                    byName[t.Name] = t;

                    // 클래스명 == "IdRow"
                    if (t.Name.EndsWith("Row", StringComparison.OrdinalIgnoreCase))
                    {
                        var key = t.Name.Substring(0, t.Name.Length - "Row".Length);
                        if (!string.IsNullOrWhiteSpace(key)) byNameRow[key] = t;
                    }

                    // 확장 관습: IdModel / IdDataModel
                    if (t.Name.EndsWith("DataModel", StringComparison.OrdinalIgnoreCase))
                    {
                        var key = t.Name.Substring(0, t.Name.Length - "DataModel".Length);
                        if (!string.IsNullOrWhiteSpace(key)) byName[key] = t;
                        continue;
                    }
                    if (t.Name.EndsWith("Model", StringComparison.OrdinalIgnoreCase))
                    {
                        var key = t.Name.Substring(0, t.Name.Length - "Model".Length);
                        if (!string.IsNullOrWhiteSpace(key)) byName[key] = t;

                        if (key.EndsWith("Data", StringComparison.OrdinalIgnoreCase))
                        {
                            var key2 = key.Substring(0, key.Length - "Data".Length);
                            if (!string.IsNullOrWhiteSpace(key2)) byName[key2] = t;
                        }
                    }
                }
            }
        }
    }

    // SerializedProperty 편의 확장
    internal static class SerializedPropertyExt
    {
        public static void SetString(this SerializedProperty p, string v) { if (p != null) p.stringValue = v; }
        public static void SetObject(this SerializedProperty p, UnityEngine.Object o) { if (p != null) p.objectReferenceValue = o; }
    }
}
#endif

```

## Assets\SDProject\Scripts\DataTable\Editor\DataTableConfigSyncEditor.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Editor\DataTableConfigSyncEditor.cs.Extension)
#if UNITY_EDITOR
using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace SD.DataTable.Editor
{
    [CustomEditor(typeof(DataTableConfig))]
    public class DataTableConfigInspector : UnityEditor.Editor
    {
        private const string DefaultCsvFolder = "Assets/SDProject/DataTables/Csv";

        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();

            GUILayout.Space(8);
            EditorGUILayout.LabelField("Auto-Sync", EditorStyles.boldLabel);

            // 폴더 선택
            string folder = EditorPrefs.GetString("SD.DataTable.CsvFolder", DefaultCsvFolder);
            EditorGUI.BeginChangeCheck();
            folder = EditorGUILayout.TextField("CSV Folder", folder);
            if (EditorGUI.EndChangeCheck())
                EditorPrefs.SetString("SD.DataTable.CsvFolder", folder);

            using (new EditorGUI.DisabledScope(!AssetDatabase.IsValidFolder(folder)))
            {
                if (GUILayout.Button("Sync From Folder"))
                {
                    SyncFromFolder((DataTableConfig)target, folder);
                }
            }

            EditorGUILayout.HelpBox("CSV 파일명을 테이블 Id로 사용합니다. Row 타입은 [DataTableId] 또는 타입명 일치로 자동 매칭합니다.", MessageType.Info);
        }

        [MenuItem("Tools/DataTables/Sync Active DataTableConfig From Folder")]
        private static void MenuSyncActive()
        {
            var cfg = Selection.activeObject as DataTableConfig;
            if (cfg == null)
            {
                Debug.LogWarning("[DataTable] Select a DataTableConfig asset first.");
                return;
            }
            string folder = EditorPrefs.GetString("SD.DataTable.CsvFolder", DefaultCsvFolder);
            SyncFromFolder(cfg, folder);
        }

        private static void SyncFromFolder(DataTableConfig config, string folder)
        {
            if (!AssetDatabase.IsValidFolder(folder))
            {
                Debug.LogError($"[DataTable] Invalid folder: {folder}");
                return;
            }

            // 1) CSV 파일 수집
            var csvGuids = AssetDatabase.FindAssets("t:TextAsset", new[] { folder });
            var csvPaths = csvGuids.Select(AssetDatabase.GUIDToAssetPath)
                                   .Where(p => p.EndsWith(".csv", StringComparison.OrdinalIgnoreCase))
                                   .Distinct()
                                   .ToList();

            // 2) 타입 인덱스 빌드
            var rowTypes = FindRowTypes(); // IHasStringId 구현 타입들
            var byAttribute = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
            var byName = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);

            foreach (var t in rowTypes)
            {
                var attr = t.GetCustomAttribute<DataTableIdAttribute>();
                if (attr != null && !string.IsNullOrWhiteSpace(attr.Id))
                    byAttribute[attr.Id] = t;

                byName[t.Name] = t;
            }

            // 3) 새 목록 만들기
            var list = new List<DataTableConfig.TableEntry>();
            foreach (var p in csvPaths)
            {
                var csv = AssetDatabase.LoadAssetAtPath<TextAsset>(p);
                var id = Path.GetFileNameWithoutExtension(p); // 파일명 = Id

                Type rowType = null;
                if (byAttribute.TryGetValue(id, out var at)) rowType = at;
                else if (byName.TryGetValue(id, out var nt)) rowType = nt;

                var entry = new DataTableConfig.TableEntry
                {
                    Id = id,
                    Csv = csv,
                    RowTypeName = rowType != null
                        ? $"{rowType.FullName}, {rowType.Assembly.GetName().Name}"
                        : string.Empty
                };

                if (rowType == null)
                    Debug.LogWarning($"[DataTable] No row type matched for Id '{id}'. (Add [DataTableId(\"{id}\")] or rename the class to '{id}')");

                list.Add(entry);
            }

            // 4) 정렬/중복 정리
            list = list.OrderBy(e => e.Id, StringComparer.OrdinalIgnoreCase).ToList();

            // 5) 적용
            Undo.RecordObject(config, "Sync DataTableConfig");
            var so = new SerializedObject(config);
            var prop = so.FindProperty("_tables");
            prop.ClearArray();
            for (int i = 0; i < list.Count; i++)
            {
                prop.InsertArrayElementAtIndex(i);
                var elem = prop.GetArrayElementAtIndex(i);
                elem.FindPropertyRelative("Id").stringValue = list[i].Id;
                elem.FindPropertyRelative("Csv").objectReferenceValue = list[i].Csv;
                elem.FindPropertyRelative("RowTypeName").stringValue = list[i].RowTypeName ?? string.Empty;
            }
            so.ApplyModifiedProperties();
            EditorUtility.SetDirty(config);

            Debug.Log($"[DataTable] Sync complete. Tables: {list.Count}");
        }

        private static IEnumerable<Type> FindRowTypes()
        {
            var result = new List<Type>();
            foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())
            {
                // Unity/Editor 등 시스템 어셈블리 대량 건너뛰기(속도 최적화)
                var name = asm.GetName().Name;
                if (name.StartsWith("Unity")) continue;
                if (name.StartsWith("System")) continue;
                if (name.StartsWith("mscorlib")) continue;
                if (name.StartsWith("netstandard")) continue;

                Type iface = typeof(IHasStringId);
                Type attr = typeof(DataTableIdAttribute);

                try
                {
                    foreach (var t in asm.GetTypes())
                    {
                        if (!t.IsClass || t.IsAbstract) continue;
                        if (iface.IsAssignableFrom(t))
                            result.Add(t);
                    }
                }
                catch { /* 일부 동적 어셈블리 예외 무시 */ }
            }
            return result;
        }
    }
}
#endif
```

## Assets\SDProject\Scripts\DataTable\Editor\ExcelCodePagesInit.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Editor\ExcelCodePagesInit.cs.Extension)
#if UNITY_EDITOR
using System.Text;

namespace SD.DataTable.Editor
{
    [UnityEditor.InitializeOnLoad]
    internal static class ExcelCodePagesInit
    {
        static ExcelCodePagesInit()
        {

            Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
        }
    }
}
#endif

```

## Assets\SDProject\Scripts\DataTable\Editor\SD.DataTables.Editor.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Editor\SD.DataTables.Editor.asmdef.Extension)
{
  "name": "SD.DataTable.Editor",
  "rootNamespace": "SD.DataTable",
  "references": [
    "SD.DataTable.Runtime"
  ],
  "includePlatforms": [ "Editor" ],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "versionDefines": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\DataTable\Editor\XlsxAssetPostprocessor.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Editor\XlsxAssetPostprocessor.cs.Extension)
#if UNITY_EDITOR
using System.IO;
using UnityEditor;

namespace SD.DataTable.Editor
{
    public sealed class XlsxAssetPostprocessor : AssetPostprocessor
    {
        private const string XlsxDir = "Assets/SDProject/DataTables/Xlsx";
        private const string CsvDir = "Assets/SDProject/DataTables/Csv";

        // 자산 임포트/변경/이동 감지 시 자동 변환
        static void OnPostprocessAllAssets(string[] imported, string[] deleted, string[] movedTo, string[] movedFrom)
        {
            bool any = false;

            void TryConvert(string assetPath)
            {
                if (!assetPath.EndsWith(".xlsx", System.StringComparison.OrdinalIgnoreCase)) return;
                if (!assetPath.StartsWith(XlsxDir)) return;

                var fullIn = Path.GetFullPath(assetPath);
                var fullOut = Path.GetFullPath(CsvDir);

                try
                {
                    XlsxToCsvConverter.ConvertXlsxToCsvFiles(fullIn, fullOut);
                    any = true;
                }
                catch (System.Exception ex)
                {
                    UnityEngine.Debug.LogError($"[XLSX→CSV] Convert failed: {assetPath}\n{ex.Message}");
                }
            }

            foreach (var p in imported) TryConvert(p);
            foreach (var p in movedTo) TryConvert(p);

            if (any)
            {
                AssetDatabase.Refresh();
            }
        }

        // 메뉴에서 수동 일괄 변환
        [MenuItem("Tools/DataTables/Convert All XLSX")]
        private static void ConvertAll()
        {
            if (!AssetDatabase.IsValidFolder(XlsxDir))
            {
                UnityEngine.Debug.LogWarning($"[XLSX→CSV] Missing folder: {XlsxDir}");
                return;
            }

            var guids = AssetDatabase.FindAssets("t:DefaultAsset", new[] { XlsxDir });
            int count = 0;
            foreach (var g in guids)
            {
                var path = AssetDatabase.GUIDToAssetPath(g);
                if (path.EndsWith(".xlsx"))
                {
                    try
                    {
                        XlsxToCsvConverter.ConvertXlsxToCsvFiles(Path.GetFullPath(path), Path.GetFullPath(CsvDir));
                        count++;
                    }
                    catch (System.Exception ex)
                    {
                        UnityEngine.Debug.LogError($"[XLSX→CSV] Convert failed: {path}\n{ex.Message}");
                    }
                }
            }
            AssetDatabase.Refresh();
            UnityEngine.Debug.Log($"[XLSX→CSV] Batch done. Converted files: {count}");
        }
    }
}
#endif

```

## Assets\SDProject\Scripts\DataTable\Editor\XlsxToCsvConverter.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Editor\XlsxToCsvConverter.cs.Extension)
#if UNITY_EDITOR
using System;
using System.IO;
using System.Text;
using ExcelDataReader; // NuGet: ExcelDataReader, ExcelDataReader.DataSet

namespace SD.DataTable.Editor
{
    internal static class XlsxToCsvConverter
    {
        // xlsx 파일 1개 → **첫 번째 시트만** CSV 1개로 출력
        // 출력 파일명: <xlsx파일명>.csv (예: CardData.xlsx → CardData.csv)
        public static void ConvertXlsxToCsvFiles(string xlsxFullPath, string outDir)
        {
            Directory.CreateDirectory(outDir);

            var fileName = Path.GetFileName(xlsxFullPath);
            if (string.IsNullOrEmpty(fileName) || fileName.StartsWith("~$"))
                return; // 임시/잠금파일 무시

            var csvOutPath = Path.Combine(outDir, $"{Path.GetFileNameWithoutExtension(xlsxFullPath)}.csv");

            using var stream = File.Open(xlsxFullPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
            using var reader = ExcelReaderFactory.CreateReader(stream);

            // 첫 번째 시트만 처리 (NextResult 호출 없음)
            int rowCount = 0;
            using var sw = new StreamWriter(csvOutPath, false, new UTF8Encoding(false)); // UTF-8 (no BOM)

            while (reader.Read())
            {
                rowCount++;
                int cellCount = reader.FieldCount;
                var line = new string[cellCount];

                for (int i = 0; i < cellCount; i++)
                {
                    var val = reader.GetValue(i)?.ToString() ?? string.Empty;
                    line[i] = CsvEscape(val);
                }
                sw.WriteLine(string.Join(",", line));
            }

            UnityEngine.Debug.Log($"[XLSX→CSV] {fileName} (Sheet#1 only) → {csvOutPath} ({rowCount} rows)");
        }

        private static string CsvEscape(string s)
        {
            bool needQuote = s.Contains(",") || s.Contains("\"") || s.Contains("\n") || s.Contains("\r");
            if (s.Contains("\"")) s = s.Replace("\"", "\"\"");
            return needQuote ? $"\"{s}\"" : s;
        }
    }
}
#endif
```

## Assets\SDProject\Scripts\DataTable\Runtime\CsvReader.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\CsvReader.cs.Extension)
using System.Collections.Generic;
using System.Text;

namespace SD.DataTable
{
    internal static class CsvReader
    {
        public static List<string[]> Parse(string text)
        {
            var result = new List<string[]>();
            if (string.IsNullOrEmpty(text)) return result;

            var row = new List<string>();
            var sb = new StringBuilder();
            bool inQuotes = false;

            for (int i = 0; i < text.Length; i++)
            {
                char c = text[i];
                if (inQuotes)
                {
                    if (c == '"')
                    {
                        if (i + 1 < text.Length && text[i + 1] == '"') { sb.Append('"'); i++; }
                        else inQuotes = false;
                    }
                    else sb.Append(c);
                }
                else
                {
                    if (c == '"') inQuotes = true;
                    else if (c == ',') { row.Add(sb.ToString()); sb.Clear(); }
                    else if (c == '\n')
                    {
                        row.Add(sb.ToString()); sb.Clear();
                        result.Add(row.ToArray()); row.Clear();
                    }
                    else if (c != '\r') sb.Append(c);
                }
            }
            row.Add(sb.ToString());
            result.Add(row.ToArray());
            return result;
        }
    }
}
```

## Assets\SDProject\Scripts\DataTable\Runtime\DataTableConfig.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\DataTableConfig.cs.Extension)
using System.Collections.Generic;
using UnityEngine;

namespace SD.DataTable
{
    [CreateAssetMenu(menuName = "SD/DataTables/Config", fileName = "DataTableConfig")]
    public sealed class DataTableConfig : ScriptableObject
    {
        [System.Serializable]
        public struct TableEntry
        {
            public string Id;
            public TextAsset Csv;
            public string RowTypeName; // AssemblyQualifiedName
        }

        [SerializeField] private bool _enabled = true;
        public bool Enabled => _enabled;

        [SerializeField] private List<TableEntry> _tables = new();
        public IReadOnlyList<TableEntry> Tables => _tables;
    }
}

```

## Assets\SDProject\Scripts\DataTable\Runtime\DataTableIdAttribute.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\DataTableIdAttribute.cs.Extension)
using System;

namespace SD.DataTable
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    public sealed class DataTableIdAttribute : Attribute
    {
        public string Id { get; }
        public DataTableIdAttribute(string id) => Id = id;
    }
}

```

## Assets\SDProject\Scripts\DataTable\Runtime\DataTableLoader.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\DataTableLoader.cs.Extension)
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace SD.DataTable
{
    [DefaultExecutionOrder(-100)]
    public sealed partial class DataTableLoader : MonoBehaviour
    {
        [Serializable]
        private struct TableEntry
        {
            public string Id;
            public TextAsset Csv;
            public string RowTypeName; // AssemblyQualifiedName
        }

        [SerializeField] private bool _enabled = true;
        [SerializeField] private List<TableEntry> _tables = new();

        private void Awake()
        {
            if (!_enabled) return;
            LoadAll();
        }

        public void LoadAll()
        {
            foreach (var t in _tables)
            {
                try
                {
                    if (t.Csv == null)
                    {
                        Debug.LogWarning($"[DataTable] Load skipped: {t.Id} :: CSV is null");
                        continue;
                    }

                    if (string.IsNullOrWhiteSpace(t.RowTypeName))
                    {
                        Debug.LogError(
                            $"[DataTable] Load skipped: {t.Id} :: RowTypeName is empty. " +
                            $"Tools > DataTables > Sync All Configs Now 실행 또는 Row 타입에 [SD.DataTable.DataTableId(\"{t.Id}\")] 특성을 부여하세요.");
                        continue;
                    }

                    var rowType = Type.GetType(t.RowTypeName, throwOnError: false);
                    if (rowType == null)
                    {
                        Debug.LogError($"[DataTable] Load failed: {t.Id} :: Cannot resolve type '{t.RowTypeName}'");
                        continue;
                    }

                    // 핵심: 비제네릭 IList로 결과 수집 (제네릭 캐스팅 없음)
                    var rows = BuildRows(t.Csv.text, rowType);

                    // TODO: 프로젝트의 실제 등록 경로에 맞게 교체
                    SD.DataTable.TableRegistry.Set(t.Id, rows);
                    Debug.Log($"[DataTable] Loaded {t.Id} → {rowType.Name} ({rows?.Count ?? 0} rows)");
                    Debug.Log($"[DataTable] Loaded {t.Id} rows={(rows as System.Collections.ICollection)?.Count ?? 0}");

                }
                catch (Exception ex)
                {
                    Debug.LogError($"[DataTable] Load failed: {t.Id} :: {ex.Message}");
                }
            }
        }

        /// <summary>
        /// CSV 텍스트를 rowType으로 매핑한 행 리스트를 반환한다.
        /// 반환 타입은 비제네릭 IList (List&lt;rowType&gt;를 박싱).
        /// </summary>
        private static IList BuildRows(string csvText, Type rowType)
        {
            if (string.IsNullOrWhiteSpace(csvText))
                return (IList)Activator.CreateInstance(typeof(List<>).MakeGenericType(rowType));

            var lines = ReadCsv(csvText);            // RFC4180 간이 파서
            if (lines.Count == 0)                    // 빈 파일
                return (IList)Activator.CreateInstance(typeof(List<>).MakeGenericType(rowType));

            var header = lines[0].Select(h => h.Trim()).ToArray();
            var listType = typeof(List<>).MakeGenericType(rowType);
            var list = (IList)Activator.CreateInstance(listType);

            // 멤버 인덱스(헤더→프로퍼티/필드) 준비
            var members = CacheMembers(rowType, header);

            // 행 파싱
            for (int r = 1; r < lines.Count; r++)
            {
                var row = Activator.CreateInstance(rowType);
                var cells = lines[r];
                int n = Math.Min(header.Length, cells.Length);

                for (int c = 0; c < n; c++)
                {
                    var m = members[c];
                    if (m == null) continue;
                    var text = cells[c];

                    try
                    {
                        if (m is PropertyInfo pi)
                        {
                            if (!pi.CanWrite) continue;
                            var val = ConvertFromString(text, pi.PropertyType);
                            pi.SetValue(row, val);
                        }
                        else if (m is FieldInfo fi)
                        {
                            var val = ConvertFromString(text, fi.FieldType);
                            fi.SetValue(row, val);
                        }
                    }
                    catch (Exception e)
                    {
                        Debug.LogWarning($"[DataTable] Convert failed @ row {r + 1}, col {c + 1} ({header[c]}='{text}') → {e.Message}");
                    }
                }

                list.Add(row);
            }

            return list;
        }

        // --- Helpers ---------------------------------------------------------

        private static List<string[]> ReadCsv(string text)
        {
            var result = new List<string[]>();
            using var sr = new StringReader(text);

            var row = new List<string>();
            var sb = new System.Text.StringBuilder();
            bool inQuotes = false;

            while (true)
            {
                int c = sr.Read();
                if (c == -1)
                {
                    if (inQuotes) throw new InvalidDataException("CSV: unmatched quotes");
                    if (sb.Length > 0 || row.Count > 0)
                    {
                        row.Add(sb.ToString()); sb.Clear();
                        result.Add(row.ToArray()); row.Clear();
                    }
                    break;
                }

                char ch = (char)c;
                if (inQuotes)
                {
                    if (ch == '"')
                    {
                        int next = sr.Peek();
                        if (next == '"') { sr.Read(); sb.Append('"'); }
                        else inQuotes = false;
                    }
                    else sb.Append(ch);
                }
                else
                {
                    if (ch == '"') inQuotes = true;
                    else if (ch == ',') { row.Add(sb.ToString()); sb.Clear(); }
                    else if (ch == '\n') { row.Add(sb.ToString()); sb.Clear(); result.Add(row.ToArray()); row.Clear(); }
                    else if (ch == '\r') { /* ignore */ }
                    else sb.Append(ch);
                }
            }

            return result;
        }

        /// <summary>헤더 순서대로 매칭되는 멤버 캐시(없으면 null).</summary>
        private static MemberInfo[] CacheMembers(Type rowType, string[] header)
        {
            var flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.IgnoreCase;
            var props = rowType.GetProperties(flags).ToDictionary(p => p.Name, StringComparer.OrdinalIgnoreCase);
            var fields = rowType.GetFields(flags).ToDictionary(f => f.Name, StringComparer.OrdinalIgnoreCase);

            var result = new MemberInfo[header.Length];
            for (int i = 0; i < header.Length; i++)
            {
                var name = header[i];
                if (string.IsNullOrWhiteSpace(name)) { result[i] = null; continue; }

                if (props.TryGetValue(name, out var p)) result[i] = p;
                else if (fields.TryGetValue(name, out var f)) result[i] = f;
                else result[i] = null; // 매칭되는 멤버 없음
            }
            return result;
        }

        private static object ConvertFromString(string s, Type target)
        {
            if (target == typeof(string)) return s ?? string.Empty;
            if (target == typeof(int)) return int.TryParse(s, out var i) ? i : 0;
            if (target == typeof(float)) return float.TryParse(s, out var f) ? f : 0f;
            if (target == typeof(double)) return double.TryParse(s, out var d) ? d : 0d;
            if (target == typeof(bool)) return !string.IsNullOrEmpty(s) && (s == "1" || s.Equals("true", StringComparison.OrdinalIgnoreCase) || s.Equals("yes", StringComparison.OrdinalIgnoreCase));

            if (target.IsEnum)
            {
                try { return Enum.Parse(target, s, ignoreCase: true); }
                catch { return Activator.CreateInstance(target); }
            }

            // Nullable<T>
            var u = Nullable.GetUnderlyingType(target);
            if (u != null)
            {
                if (string.IsNullOrWhiteSpace(s)) return null;
                return ConvertFromString(s, u);
            }

            // 기타 구조체/복합타입은 JSON으로 시도 (["..."], {"...":...} 형태)
            if (!string.IsNullOrWhiteSpace(s) && (s.StartsWith("{") || s.StartsWith("[")))
            {
                try
                {
                    // UnityEngine.JsonUtility는 루트 배열 미지원 → 래핑
                    if (s.StartsWith("["))
                    {
                        var wrapperType = typeof(Wrapper<>).MakeGenericType(target);
                        var json = "{\"Items\":" + s + "}";
                        var wrapper = JsonUtility.FromJson(json, wrapperType);
                        var itemsProp = wrapperType.GetField("Items");
                        return itemsProp?.GetValue(wrapper);
                    }
                    return JsonUtility.FromJson(s, target);
                }
                catch { /* 무시 후 null */ }
            }

            return target.IsValueType ? Activator.CreateInstance(target) : null;
        }

        [Serializable] private class Wrapper<T> { public T Items; }
    }
}

```

## Assets\SDProject\Scripts\DataTable\Runtime\ICsvTable.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\ICsvTable.cs.Extension)
using System.Collections.Generic;

namespace SD.DataTable
{
    public interface ICsvTable<TRow> where TRow : IHasStringId
    {
        IReadOnlyDictionary<string, TRow> ById { get; }
        IReadOnlyList<TRow> Rows { get; }
        bool TryGet(string id, out TRow row);
        TRow GetOrNull(string id);
    }
}

```

## Assets\SDProject\Scripts\DataTable\Runtime\IHasStringId.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\IHasStringId.cs.Extension)
namespace SD.DataTable
{
    public interface IHasStringId
    {
        string Id { get; }
    }
}

```

## Assets\SDProject\Scripts\DataTable\Runtime\ReflectionMapper.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\ReflectionMapper.cs.Extension)
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;

namespace SD.DataTable
{
    internal static class ReflectionMapper
    {
        public static T MapRow<T>(IReadOnlyDictionary<string, int> headerIndex, string[] row) where T : new()
        {
            var obj = new T();
            var t = typeof(T);
            foreach (var p in t.GetProperties(BindingFlags.Public | BindingFlags.Instance))
            {
                if (!p.CanWrite) continue;
                if (!headerIndex.TryGetValue(p.Name, out int c)) continue;
                if (c < 0 || c >= row.Length) continue;

                string cell = row[c]?.Trim() ?? "";
                p.SetValue(obj, ConvertCell(cell, p.PropertyType));
            }
            return obj;
        }

        private static object ConvertCell(string s, Type type)
        {
            if (type == typeof(string)) return s;
            if (type == typeof(bool)) return s.Equals("true", StringComparison.OrdinalIgnoreCase) || s == "1";
            if (type == typeof(int)) return int.TryParse(s, NumberStyles.Any, CultureInfo.InvariantCulture, out var i) ? i : 0;
            if (type == typeof(float)) return float.TryParse(s, NumberStyles.Any, CultureInfo.InvariantCulture, out var f) ? f : 0f;
            if (type == typeof(double)) return double.TryParse(s, NumberStyles.Any, CultureInfo.InvariantCulture, out var d) ? d : 0d;
            if (type.IsEnum)
            {
                try { return Enum.Parse(type, s, true); }
                catch { return Activator.CreateInstance(type)!; }
            }
            return Activator.CreateInstance(type)!;
        }
    }
}
```

## Assets\SDProject\Scripts\DataTable\Runtime\SD.DataTables.Runtime.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\SD.DataTables.Runtime.asmdef.Extension)
{
    "name": "SD.DataTable.Runtime",
    "rootNamespace": "SD.DataTable",
    "references": [],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}
```

## Assets\SDProject\Scripts\DataTable\Runtime\Table.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\Table.cs.Extension)
using System.Collections.Generic;
using UnityEngine;

namespace SD.DataTable
{
    public class Table<TRow> : ICsvTable<TRow> where TRow : IHasStringId
    {
        private readonly Dictionary<string, TRow> _byId = new();
        private readonly List<TRow> _rows;

        public Table(List<TRow> rows)
        {
            _rows = rows ?? new List<TRow>();
            foreach (var r in _rows)
            {
                if (r == null || string.IsNullOrEmpty(r.Id))
                {
                    Debug.LogError($"[DataTable] Null/Empty Id in {typeof(TRow).Name}");
                    continue;
                }
                if (_byId.ContainsKey(r.Id))
                {
                    Debug.LogError($"[DataTable] Duplicate Id '{r.Id}' in {typeof(TRow).Name}");
                    continue;
                }
                _byId[r.Id] = r;
            }
        }

        public IReadOnlyDictionary<string, TRow> ById => _byId;
        public IReadOnlyList<TRow> Rows => _rows;
        public bool TryGet(string id, out TRow row) => _byId.TryGetValue(id, out row!);
        public TRow GetOrNull(string id) => _byId.TryGetValue(id, out var r) ? r : default!;
    }
}
```

## Assets\SDProject\Scripts\DataTable\Runtime\TableRegistry.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\TableRegistry.cs.Extension)
using System.Collections;
using System.Collections.Generic;

namespace SD.DataTable
{
    /// <summary>
    /// DataTableLoader가 로드한 테이블(IList)을 Id로 보관/조회하는 전역 레지스트리.
    /// 런타임에서 읽기 전용으로만 사용하세요.
    /// </summary>
    public static class TableRegistry
    {
        private static readonly Dictionary<string, IList> _tables = new Dictionary<string, IList>(System.StringComparer.OrdinalIgnoreCase);

        /// <summary>로드 시점에만 사용: 테이블 등록/갱신.</summary>
        public static void Set(string id, IList rows)
        {
            if (string.IsNullOrWhiteSpace(id)) return;
            _tables[id] = rows ?? (IList)System.Array.Empty<object>();
        }

        /// <summary>조회: 없으면 null 반환.</summary>
        public static IList Get(string id)
        {
            if (string.IsNullOrWhiteSpace(id)) return null;
            return _tables.TryGetValue(id, out var list) ? list : null;
        }

        /// <summary>조회: 없으면 비어있는 리스트 반환(Null-안전).</summary>
        public static IList GetOrEmpty(string id)
        {
            return Get(id) ?? (IList)System.Array.Empty<object>();
        }

        /// <summary>초기화(필요 시).</summary>
        public static void Clear() => _tables.Clear();
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Domain\SD.Gameplay.Battle.Domain.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Domain\SD.Gameplay.Battle.Domain.asmdef.Extension)
{
  "name": "SD.Gameplay.Battle.Domain",
  "references": [
    "SD.Core.Domain",
    "SD.Gameplay.Cards.Domain"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Infrastructure\SD.Gameplay.Battle.Infrastructure.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Infrastructure\SD.Gameplay.Battle.Infrastructure.asmdef.Extension)
{
  "name": "SD.Gameplay.Battle.Infrastructure",
  "references": [
    "SD.Gameplay.Battle.Domain",
    "SD.Core.Infrastructure"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Presentation\SD.Gameplay.Battle.Presentation.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Presentation\SD.Gameplay.Battle.Presentation.asmdef.Extension)
{
  "name": "SD.Gameplay.Battle.Presentation",
  "references": [
    "SD.Gameplay.Battle.Domain",
    "SD.Core.Presentation"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Tests\SD.Gameplay.Tests.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Tests\SD.Gameplay.Tests.asmdef.Extension)
{
  "name": "SD.Gameplay.Tests",
  "references": [
    "SD.Gameplay.Battle.Domain",
    "SD.Gameplay.Battle.Infrastructure",
    "SD.Core.Infrastructure",
    "SD.Gameplay.Cards.Domain"
  ],
  "includePlatforms": [
    "Editor"
  ],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false,
  "optionalUnityReferences": [
    "TestAssemblies"
  ]
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardDataModel.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardDataModel.cs.Extension)
using System.Collections.Generic;
using SD.DataTable;

namespace SD.Gameplay.Cards.Domain
{
    [DataTableId("CardData")]
    public sealed class CardDataModel
    {
        public string Id { get; set; }
        public bool Enabled { get; set; }
        public string NameId { get; set; }
        public string DescId { get; set; }
        public CardType Type { get; set; }
        public CardClass Class { get; set; }
        public CardRarity Rarity { get; set; }
        public string CharId { get; set; }
        public int Cost { get; set; }
        public TargetType TargetType { get; set; }
        public PositionUseFlags PosUse { get; set; }
        public PositionHitFlags PosHit { get; set; }
        public IReadOnlyList<CardEffect> Effects { get; set; }
        public bool Upgradable { get; set; }
        public int UpgradeStep { get; set; }
        public string UpgradeRefId { get; set; }
        public CardTagFlags Tags { get; set; }

        public CardDataModel(
            string id, bool enabled, string nameId, string descId,
            CardType type, CardClass @class, CardRarity rarity, string charId,
            int cost, TargetType targetType, PositionUseFlags posUse, PositionHitFlags posHit,
            List<CardEffect> effects, bool upgradable, int upgradeStep, string upgradeRefId, CardTagFlags tags)
        {
            Id = id; Enabled = enabled; NameId = nameId; DescId = descId;
            Type = type; Class = @class; Rarity = rarity; CharId = charId;
            Cost = cost; TargetType = targetType; PosUse = posUse; PosHit = posHit;
            Effects = effects ?? new List<CardEffect>();
            Upgradable = upgradable; UpgradeStep = upgradeStep; UpgradeRefId = upgradeRefId; Tags = tags;
        }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardDefinition.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardDefinition.cs.Extension)
using System.Collections.Generic;

namespace SD.Gameplay.Cards.Domain
{
    /// <summary>
    /// 런타임에서 카드 한 장을 표현하기 위한 최소 정의.
    /// CSV(CardData/Name/Desc)로부터 CardFactory가 생성한다.
    /// </summary>
    public sealed class CardDefinition
    {
        // 키/활성
        public string Id { get; set; }
        public bool Enabled { get; set; }

        // 로컬라이즈 키 & 결과
        public string NameId { get; set; }
        public string DescId { get; set; }
        public string DisplayName { get; set; }
        public string DisplayDesc { get; set; }

        // 기본 속성
        public CardType Type { get; set; }
        public CardClass Class { get; set; }      // Myth 단일화 반영
        public CardRarity Rarity { get; set; }
        public string CharId { get; set; }
        public int Cost { get; set; }

        public TargetType TargetType { get; set; }
        public PositionUseFlags PosUse { get; set; }
        public PositionHitFlags PosHit { get; set; }

        // 태그(자유 문자열; v1은 플래그 미사용)
        public List<string> Tags { get; set; } = new();

        // 효과(선택: 별도 모듈에서 해석/실행)
        public List<Effects.EffectSpec> Effects { get; set; } = new();

        // 업그레이드 메타
        public bool Upgradable { get; set; }
        public int UpgradeStep { get; set; }
        public string UpgradeRefId { get; set; }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardEffects.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardEffects.cs.Extension)
using System.Collections.Generic;

namespace SD.Gameplay.Cards.Domain
{
    public enum EffectType { Damage, Heal, Shield, Buff, Debuff, Knockback, Pull, Push }

    [System.Serializable]
    public class CardEffect
    {
        public EffectType Type;
        public int Value;
        public int Duration;
        public int Cells; // 위치 이동 계열
    }

    [System.Serializable]
    public class CardEffectArray { public List<CardEffect> Items = new(); }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardEnums.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardEnums.cs.Extension)
namespace SD.Gameplay.Cards.Domain
{
    public enum CardType { Unknown = 0, Attack = 1, Defense = 2, Support = 3, Move = 4 }

    public enum CardClass { Unknown = 0, Base = 1, Character = 2, Myth = 3 }

    public enum CardRarity { Unknown = 0, Common = 1, Rare = 2 }
    public enum TargetType { Unknown = 0, Self = 1, Ally = 2, AllyAll = 3, Enemy = 4, EnemyAll = 5, AllyThenEnemy = 6 }

    [System.Flags]
    public enum PositionUseFlags { None = 0, Front = 1 << 0, Mid1 = 1 << 1, Mid2 = 1 << 2, Back = 1 << 3 }

    [System.Flags]
    public enum PositionHitFlags { None = 0, Front = 1 << 0, Mid1 = 1 << 1, Mid2 = 1 << 2, Mid3 = 1 << 3, Back = 1 << 4 }

    [System.Flags]
    public enum CardTagFlags { None = 0 }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\Effects\EffectModel.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\Effects\EffectModel.cs.Extension)
using System.Collections.Generic;
using UnityEngine;

namespace SD.Gameplay.Cards.Domain.Effects
{
    /// <summary>
    /// 런타임에서 사용되는 표준 이펙트 포맷(정규화 결과).
    /// </summary>
    [System.Serializable]
    public struct EffectSpec
    {
        public string effect;   // "Damage" 만 사용(v1)
        public float value;     // 수치
        public float duration;  // 선택
        public string arg;      // 선택
    }

    // 입력 JSON을 받기 위한 "raw" 구조체 (type/effect 둘 다 허용)
    [System.Serializable]
    internal struct EffectSpecRaw
    {
        public string type;     // 예: "Damage"
        public string effect;   // 예: "Damage"
        public float value;
        public float duration;
        public string arg;

        public EffectSpec Normalize()
        {
            var eff = string.IsNullOrWhiteSpace(effect) ? type : effect;
            return new EffectSpec
            {
                effect = eff,
                value = value,
                duration = duration,
                arg = arg
            };
        }
    }

    // JsonUtility는 루트 배열을 직접 못 읽어서 래핑
    [System.Serializable]
    internal class EffectArrayWrapper { public EffectSpecRaw[] items; }

    public static class EffectJsonParser
    {
        /// <summary>
        /// 최소 동작: [{"type":"Damage","value":1}] 또는 [{"effect":"Damage","value":1}]
        /// - 허용: 배열/단일객체
        /// - "Damage" 외 타입은 무시
        /// - 파싱 실패 시 빈 리스트 반환(에러 대신 경고)
        /// </summary>
        public static List<EffectSpec> Parse(string json)
        {
            var list = new List<EffectSpec>();
            if (string.IsNullOrWhiteSpace(json)) return list;

            try
            {
                var trimmed = json.TrimStart();

                if (trimmed.StartsWith("["))
                {
                    // 배열 → 래핑
                    var wrapped = "{\"items\":" + json + "}";
                    var rawArr = JsonUtility.FromJson<EffectArrayWrapper>(wrapped);
                    if (rawArr?.items != null)
                    {
                        foreach (var r in rawArr.items)
                        {
                            var spec = r.Normalize();
                            if (IsSupported(spec)) list.Add(spec);
                        }
                    }
                }
                else
                {
                    // 단일 객체
                    var raw = JsonUtility.FromJson<EffectSpecRaw>(json);
                    var spec = raw.Normalize();
                    if (IsSupported(spec)) list.Add(spec);
                }
            }
            catch
            {
                Debug.LogWarning($"[Effect] Parse failed: {json}");
            }

            return list;
        }

        // v1에서는 Damage만 허용(나머지는 무시)
        private static bool IsSupported(EffectSpec spec)
            => !string.IsNullOrWhiteSpace(spec.effect) &&
               spec.effect.Equals("Damage", System.StringComparison.OrdinalIgnoreCase);
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\ICardRepository.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\ICardRepository.cs.Extension)
using System.Collections.Generic;

namespace SD.Gameplay.Cards.Domain
{
    public interface ICardRepository
    {
        bool TryGet(string id, out CardDataModel card);
        IEnumerable<CardDataModel> All { get; }
        int Count { get; }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\Localization\CardTextRows.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\Localization\CardTextRows.cs.Extension)
using SD.DataTable;

namespace SD.Gameplay.Cards.Domain.Localization
{
    /// <summary>
    /// CardName.csv → (Id, Ko, En, …)
    /// 기획서: Id = 로컬라이즈 키, Ko/En = 언어별 텍스트
    /// </summary>
    [DataTableId("CardName")]
    public sealed class CardNameRow : IHasStringId
    {
        // CSV 헤더와 동일한 public set 가능 프로퍼티여야 ReflectionMapper가 채워 넣습니다.
        public string Id { get; set; }
        public string Ko { get; set; }
        public string En { get; set; }
        // 필요 시 추가 언어 컬럼도 그대로 프로퍼티로 확장: public string Jp { get; set; } 등
    }

    /// <summary>
    /// CardDesc.csv → (Id, Ko, En, …)
    /// </summary>
    [DataTableId("CardDesc")]
    public sealed class CardDescRow : IHasStringId
    {
        public string Id { get; set; }
        public string Ko { get; set; }
        public string En { get; set; }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\SD.Gameplay.Cards.Domain.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\SD.Gameplay.Cards.Domain.asmdef.Extension)
{
  "name": "SD.Gameplay.Cards.Domain",
  "rootNamespace": "SD.Gameplay.Cards.Domain",
  "references": [
    "SD.DataTable.Runtime"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "versionDefines": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\CardCatalog.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\CardCatalog.cs.Extension)
using System.Collections.Generic;
using UnityEngine;
using SD.Gameplay.Cards.Domain;

namespace SD.Gameplay.Cards.Infrastructure
{
    /// <summary>런타임 카드 데이터 저장소(싱글톤).</summary>
    public sealed class CardCatalog : MonoBehaviour
    {
        public static CardCatalog Instance { get; private set; }
        private List<CardDefinition> _cards = new();
        public IReadOnlyList<CardDefinition> All => _cards;

        private void Awake()
        {
            if (Instance != null && Instance != this) { Destroy(gameObject); return; }
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }

        public void Set(List<CardDefinition> cards) => _cards = cards ?? new();

        public CardDefinition FindById(string id) =>
            _cards.Find(c => c.Id.Equals(id, System.StringComparison.OrdinalIgnoreCase));
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\CardFactory.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\CardFactory.cs.Extension)
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;
using SD.Gameplay.Cards.Domain;
using SD.Gameplay.Cards.Domain.Effects;           // EffectJsonParser / EffectSpec
using SD.Gameplay.Cards.Domain.Localization;      // CardNameRow / CardDescRow

namespace SD.Gameplay.Cards.Infrastructure
{
    /// <summary>
    /// CSV 로우(IList)들을 묶어 CardDefinition 리스트를 생성.
    /// - 필드 타입(string/enum/flags/int)을 리플렉션으로 관대하게 수용
    /// - Effects: EffectModel의 EffectJsonParser.Parse만 사용 (Damage만 허용)
    /// - 파싱 실패는 Unknown/기본값으로 안전 귀결 + 경고 로그
    /// </summary>
    public static class CardFactory
    {
        public static List<CardDefinition> BuildAll(
            IList cardDataRows,   // List<CardDataModel> as IList
            IList nameRows,       // List<CardNameRow>  as IList
            IList descRows,       // List<CardDescRow>  as IList
            string locale = null  // "ko"|"en" (null이면 시스템 언어)
        )
        {
            var result = new List<CardDefinition>();
            if (cardDataRows == null) return result;

            // 로컬라이즈 맵
            var nameMap = ToTextMap(nameRows);
            var descMap = ToTextMap(descRows);
            var lang = NormalizeLocale(locale);

            foreach (var row in cardDataRows.Cast<object>())
            {
                try
                {
                    var enabled = GetBool(row, true, "Enabled", "IsEnabled", "Enable");
                    if (!enabled) continue;

                    var id = GetString(row, "Id");
                    var nameId = GetString(row, "NameId");
                    var descId = GetString(row, "DescId");

                    var def = new CardDefinition
                    {
                        Id = id,
                        Enabled = enabled,

                        NameId = nameId,
                        DescId = descId,
                        DisplayName = ResolveText(nameMap, nameId, lang),
                        DisplayDesc = ResolveText(descMap, descId, lang),

                        Type = GetEnum<CardType>(row, "Type", CardType.Unknown),
                        Class = GetEnum<CardClass>(row, "Class", CardClass.Unknown, normalize: NormalizeClass),
                        Rarity = GetEnum<CardRarity>(row, "Rarity", CardRarity.Unknown),

                        CharId = GetString(row, "CharId"),
                        Cost = GetInt(row, "Cost", 0),

                        TargetType = GetEnum<TargetType>(row, "TargetType", TargetType.Unknown),

                        PosUse = GetFlags<PositionUseFlags>(row, "PosUse", ParseUseFlags),
                        PosHit = GetFlags<PositionHitFlags>(row, "PosHit", ParseHitFlags),

                        // 이펙트: 최소 구현(Damage만) - 여러 후보 필드명 지원
                        Effects = EffectJsonParser.Parse(
                            FirstNonEmpty(
                                GetString(row, "EffectsJSON"),
                                GetString(row, "EffectsJson"),
                                GetString(row, "EffectsText"),
                                GetString(row, "Effects")
                            ) ?? string.Empty
                        ),

                        Upgradable = GetBool(row, true, "Enabled", "IsEnabled", "Enable"),
                        UpgradeStep = GetInt(row, "UpgradeStep", 0),
                        UpgradeRefId = GetString(row, "UpgradeRefId"),

                        Tags = GetTags(row, "Tags"),
                    };

                    result.Add(def);
                }
                catch (Exception ex)
                {
                    Debug.LogWarning($"[CardFactory] Skip row due to error: {ex.Message}");
                }
            }

            return result;
        }

        // -------------------- Reflection helpers --------------------
        static readonly BindingFlags _bf = BindingFlags.Instance | BindingFlags.Public | BindingFlags.IgnoreCase;

        static MemberInfo FindMember(object obj, params string[] names)
        {
            var t = obj.GetType();
            foreach (var n in names)
            {
                var p = t.GetProperty(n, _bf);
                if (p != null) return p;
                var f = t.GetField(n, _bf);
                if (f != null) return f;
            }
            return null;
        }

        static object GetRaw(object obj, params string[] names)
        {
            var m = FindMember(obj, names);
            if (m == null) return null;
            return m is PropertyInfo pi ? pi.GetValue(obj) : ((FieldInfo)m).GetValue(obj);
        }

        static string GetString(object obj, params string[] names)
        {
            var v = GetRaw(obj, names);
            if (v == null) return string.Empty;
            if (v is string s) return s;
            return v.ToString();
        }

        static int GetInt(object obj, string name, int def = 0)
        {
            var v = GetRaw(obj, name);
            if (v == null) return def;
            if (v is int i) return i;
            if (int.TryParse(v.ToString(), out var p)) return p;
            return def;
        }

        static bool GetBool(object obj, bool def, params string[] names)
        {
            foreach (var name in names)
            {
                var v = GetRaw(obj, name);
                if (v == null) continue;
                if (v is bool b) return b;

                var s = v.ToString();
                if (bool.TryParse(s, out var pb)) return pb;
                if (int.TryParse(s, out var pi)) return pi != 0;
                if (s.Equals("yes", StringComparison.OrdinalIgnoreCase)) return true;
                if (s.Equals("no", StringComparison.OrdinalIgnoreCase)) return false;
            }
            return def;
        }

        static TEnum GetEnum<TEnum>(object obj, string name, TEnum def, Func<string, string> normalize = null) where TEnum : struct
        {
            var v = GetRaw(obj, name);
            if (v == null) return def;

            // 이미 enum
            if (v is TEnum e) return e;

            // 숫자 기반
            if (v is IConvertible)
            {
                try
                {
                    var i = Convert.ToInt32(v);
                    if (Enum.IsDefined(typeof(TEnum), i))
                        return (TEnum)Enum.ToObject(typeof(TEnum), i);
                }
                catch { /* ignore */ }
            }

            // 문자열
            var s = v.ToString();
            if (string.IsNullOrWhiteSpace(s)) return def;
            if (normalize != null) s = normalize(s);
            return Enum.TryParse<TEnum>(s, true, out var parsed) ? parsed : def;
        }

        static TFlags GetFlags<TFlags>(object obj, string name, Func<string, TFlags> parseFromString) where TFlags : struct
        {
            var v = GetRaw(obj, name);
            if (v == null) return parseFromString(string.Empty);

            if (v is TFlags en) return en; // 이미 Flags enum

            if (v is IConvertible)
            {
                try { return (TFlags)Enum.ToObject(typeof(TFlags), Convert.ToInt32(v)); }
                catch { /* ignore */ }
            }

            return parseFromString(v.ToString()); // 문자열 파싱
        }

        static string FirstNonEmpty(params string[] ss)
        {
            foreach (var s in ss) if (!string.IsNullOrWhiteSpace(s)) return s;
            return null;
        }

        // -------------------- Domain parsers --------------------
        static string NormalizeClass(string s)
        {
            // 과거 표기 보정: Mythic → Myth
            if (string.IsNullOrWhiteSpace(s)) return s;
            return s.Equals("Mythic", StringComparison.OrdinalIgnoreCase) ? "Myth" : s;
        }

        static PositionUseFlags ParseUseFlags(string csv)
        {
            if (string.IsNullOrWhiteSpace(csv))
                return PositionUseFlags.Front | PositionUseFlags.Mid1 | PositionUseFlags.Mid2 | PositionUseFlags.Back;

            PositionUseFlags acc = 0;
            foreach (var t in SplitTokens(csv))
            {
                if (t.Equals("Front", StringComparison.OrdinalIgnoreCase)) acc |= PositionUseFlags.Front;
                else if (t.Equals("Mid1", StringComparison.OrdinalIgnoreCase)) acc |= PositionUseFlags.Mid1;
                else if (t.Equals("Mid2", StringComparison.OrdinalIgnoreCase)) acc |= PositionUseFlags.Mid2;
                else if (t.Equals("Back", StringComparison.OrdinalIgnoreCase)) acc |= PositionUseFlags.Back;
            }
            return acc == 0 ? (PositionUseFlags.Front | PositionUseFlags.Mid1 | PositionUseFlags.Mid2 | PositionUseFlags.Back) : acc;
        }

        static PositionHitFlags ParseHitFlags(string csv)
        {
            if (string.IsNullOrWhiteSpace(csv))
                return PositionHitFlags.Front | PositionHitFlags.Mid1 | PositionHitFlags.Mid2 | PositionHitFlags.Mid3 | PositionHitFlags.Back;

            PositionHitFlags acc = 0;
            foreach (var t in SplitTokens(csv))
            {
                if (t.Equals("Front", StringComparison.OrdinalIgnoreCase)) acc |= PositionHitFlags.Front;
                else if (t.Equals("Mid1", StringComparison.OrdinalIgnoreCase)) acc |= PositionHitFlags.Mid1;
                else if (t.Equals("Mid2", StringComparison.OrdinalIgnoreCase)) acc |= PositionHitFlags.Mid2;
                else if (t.Equals("Mid3", StringComparison.OrdinalIgnoreCase)) acc |= PositionHitFlags.Mid3;
                else if (t.Equals("Back", StringComparison.OrdinalIgnoreCase)) acc |= PositionHitFlags.Back;
            }
            return acc == 0 ? (PositionHitFlags.Front | PositionHitFlags.Mid1 | PositionHitFlags.Mid2 | PositionHitFlags.Mid3 | PositionHitFlags.Back) : acc;
        }

        static List<string> GetTags(object obj, string name)
        {
            var v = GetRaw(obj, name);
            if (v == null) return new List<string>();

            // 문자열 → 구분자 파싱
            if (v is string s)
                return SplitTokens(s).Where(x => x.Length > 0).Distinct(StringComparer.OrdinalIgnoreCase).ToList();

            // Flags enum → 켜진 비트 라벨 추출
            var t = v.GetType();
            if (t.IsEnum)
            {
                var val = Convert.ToInt64(v);
                if (val == 0) return new List<string>();
                var labels = Enum.GetValues(t).Cast<object>()
                    .Select(x => new { x, i = Convert.ToInt64(x) })
                    .Where(e => e.i != 0 && (val & e.i) == e.i)
                    .Select(e => e.x.ToString())
                    .Distinct()
                    .ToList();
                return labels;
            }

            return new List<string> { v.ToString() };
        }

        // -------------------- Localization helpers --------------------
        static Dictionary<string, (string ko, string en)> ToTextMap(IList rows)
        {
            var map = new Dictionary<string, (string, string)>(StringComparer.OrdinalIgnoreCase);
            if (rows == null) return map;

            foreach (var any in rows)
            {
                switch (any)
                {
                    case CardNameRow nr: map[nr.Id] = (nr.Ko ?? "", nr.En ?? ""); break;
                    case CardDescRow dr: map[dr.Id] = (dr.Ko ?? "", dr.En ?? ""); break;
                    default:
                        Debug.LogWarning("[CardFactory] Unknown text row type: " + any?.GetType().Name);
                        break;
                }
            }
            return map;
        }

        static string NormalizeLocale(string loc)
        {
            if (string.IsNullOrEmpty(loc))
                return (Application.systemLanguage == SystemLanguage.Korean) ? "ko" : "en";

            loc = loc.ToLowerInvariant();
            if (loc.StartsWith("ko")) return "ko";
            return "en";
        }

        static string ResolveText(Dictionary<string, (string ko, string en)> map, string id, string lang)
        {
            if (string.IsNullOrWhiteSpace(id)) return string.Empty;
            if (!map.TryGetValue(id, out var t)) return id; // 키 없으면 키 자체 반환(디버그에 유용)
            return lang == "ko" ? t.ko : t.en;
        }

        // -------------------- Shared tokenization --------------------
        static IEnumerable<string> SplitTokens(string s)
            => s.Split(new[] { '|', ',', ';' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(x => x.Trim());
    }
}
```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CardCsvParser.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CardCsvParser.cs.Extension)
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using SD.Gameplay.Cards.Domain;
using UnityEngine;

namespace SD.Gameplay.Cards.Infrastructure.Csv
{
    internal static class CardCsvParser
    {
        public static List<CardDataModel> Parse(TextAsset csv)
        {
            using var sr = new StringReader(csv.text);
            var rows = CsvReader.ReadAll(sr);
            if (rows.Count == 0) return new();

            var header = rows[0].Select(h => h.Trim()).ToArray();
            int Index(string name) => Array.FindIndex(header, h => string.Equals(h, name, StringComparison.OrdinalIgnoreCase));
            int idxId = Index("Id");
            int idxEnabled = Index("Enabled");
            int idxNameId = Index("NameId");
            int idxDescId = Index("DescId");
            int idxType = Index("Type");
            int idxClass = Index("Class");
            int idxRarity = Index("Rarity");
            int idxCharId = Index("CharId");
            int idxCost = Index("Cost");
            int idxTargetType = Index("TargetType");
            int idxPosUse = Index("PosUse");
            int idxPosHit = Index("PosHit");
            int idxEffects = Index("EffectsJSON");
            int idxUpgradable = Index("Upgradable");
            int idxUpgradeStep = Index("UpgradeStep");
            int idxUpgradeRefId = Index("UpgradeRefId");
            int idxTags = Index("Tags");

            var required = new[] { idxId, idxEnabled, idxType, idxClass, idxCost, idxTargetType };
            if (required.Any(i => i < 0))
                throw new InvalidDataException("CardData.csv 필수 헤더 누락(Id, Enabled, Type, Class, Cost, TargetType)");

            var list = new List<CardDataModel>();
            var ids = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            for (int r = 1; r < rows.Count; r++)
            {
                var line = rows[r];
                string Get(int i) => (i >= 0 && i < line.Length) ? line[i]?.Trim() ?? "" : "";

                try
                {
                    string id = Get(idxId);
                    UnityEngine.Debug.LogWarning($"[CardCsvParser] 행 {r + 1}: 빈 Id");
                    UnityEngine.Debug.LogWarning($"[CardCsvParser] 행 {r + 1}: 중복 Id: {id}");

                    bool enabled = ParseBool(Get(idxEnabled));
                    if (!enabled) continue;

                    var nameId = Get(idxNameId);
                    var descId = Get(idxDescId);
                    var type = ParseEnum<CardType>(Get(idxType));
                    var @class = ParseEnum<CardClass>(Get(idxClass));
                    var rarity = ParseEnumSafe<CardRarity>(Get(idxRarity), CardRarity.Common);
                    var charId = string.IsNullOrEmpty(Get(idxCharId)) ? "Public" : Get(idxCharId);
                    int cost = ParseInt(Get(idxCost), 0);
                    var target = ParseEnum<TargetType>(Get(idxTargetType));
                    var posUse = ParseFlags<PositionUseFlags>(Get(idxPosUse));
                    var posHit = ParseFlags<PositionHitFlags>(Get(idxPosHit));
                    var effects = ParseEffects(Get(idxEffects));
                    bool upgradable = ParseBool(Get(idxUpgradable));
                    int upgradeStep = ParseInt(Get(idxUpgradeStep), 0);
                    string upgradeRefId = Get(idxUpgradeRefId);
                    var tags = ParseFlags<CardTagFlags>(Get(idxTags));

                    list.Add(new CardDataModel(id, enabled, nameId, descId, type, @class, rarity, charId,
                        cost, target, posUse, posHit, effects, upgradable, upgradeStep, upgradeRefId, tags));
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[CardCsvParser] 행 {r + 1} 파싱 실패: {ex.Message}");
                }
            }

            Debug.Log($"[CardCsvParser] 로드 완료: {list.Count}개");
            return list;
        }

        static bool ParseBool(string s) =>
            !string.IsNullOrEmpty(s) && (s.Equals("true", StringComparison.OrdinalIgnoreCase) || s == "1" || s.Equals("yes", StringComparison.OrdinalIgnoreCase));

        static int ParseInt(string s, int def) => int.TryParse(s, out var v) ? v : def;

        static T ParseEnum<T>(string s) where T : struct =>
            Enum.TryParse<T>(s, true, out var v) ? v : throw new InvalidDataException($"Enum 파싱 실패: {typeof(T).Name}='{s}'");

        static T ParseEnumSafe<T>(string s, T def) where T : struct =>
            Enum.TryParse<T>(s, true, out var v) ? v : def;

        static U ParseFlags<U>(string s) where U : struct
        {
            if (string.IsNullOrWhiteSpace(s)) return default;
            // "Front|Mid1|Back" 형태 지원
            ulong acc = 0;
            foreach (var token in s.Split('|'))
            {
                var t = token.Trim();
                if (string.IsNullOrEmpty(t)) continue;
                if (!Enum.TryParse<U>(t, true, out var part))
                    throw new InvalidDataException($"Flags 파싱 실패: {typeof(U).Name}='{t}'");
                acc |= Convert.ToUInt64(part);
            }
            return (U)Enum.ToObject(typeof(U), acc);
        }

        static List<CardEffect> ParseEffects(string json)
        {
            if (string.IsNullOrWhiteSpace(json)) return new List<CardEffect>();
            try
            {
                // 표준 형태: [{"type":"Damage","value":6},{"type":"Knockback","cells":1}] (기획서 정의) :contentReference[oaicite:4]{index=4}
                var wrapper = new Wrapper { Items = JsonUtility.FromJson<CardEffectArray>("{\"Items\":" + json + "}").Items };
                return wrapper.Items ?? new List<CardEffect>();
            }
            catch (Exception e)
            {
                Debug.LogError($"[CardCsvParser] EffectsJSON 파싱 실패: {e.Message} / 원본: {json}");
                return new List<CardEffect>();
            }
        }

        [System.Serializable] class Wrapper { public List<CardEffect> Items; }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CardCsvRow.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CardCsvRow.cs.Extension)
namespace SD.Gameplay.Cards.Infrastructure.Csv
{
    internal struct CardCsvRow
    {
        public string Id, Enabled, NameId, DescId, Type, Class, Rarity, CharId, Cost,
                      TargetType, PosUse, PosHit, EffectsJSON, Upgradable, UpgradeStep, UpgradeRefId, Tags;
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CsvCardRepository.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CsvCardRepository.cs.Extension)
using System.Collections.Generic;
using System.Linq;
using SD.Gameplay.Cards.Domain;
using UnityEngine;

namespace SD.Gameplay.Cards.Infrastructure.Csv
{
    public sealed class CsvCardRepository : ICardRepository
    {
        private readonly Dictionary<string, CardDataModel> _byId;

        public CsvCardRepository(TextAsset cardDataCsv)
        {
            var list = CardCsvParser.Parse(cardDataCsv);
            _byId = new Dictionary<string, CardDataModel>(list.Count, System.StringComparer.OrdinalIgnoreCase);
            foreach (var c in list) _byId[c.Id] = c;
        }

        public bool TryGet(string id, out CardDataModel card) => _byId.TryGetValue(id, out card);
        public IEnumerable<CardDataModel> All => _byId.Values;
        public int Count => _byId.Count;
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CsvReader.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CsvReader.cs.Extension)
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace SD.Gameplay.Cards.Infrastructure.Csv
{
    internal static class CsvReader
    {
        // RFC4180 호환 간단판: 따옴표로 감싼 필드의 콤마 허용, "" → " 이스케이프 처리
        public static List<string[]> ReadAll(TextReader reader, char delimiter = ',')
        {
            var result = new List<string[]>();
            var row = new List<string>();
            var sb = new StringBuilder();
            bool inQuotes = false;

            while (true)
            {
                int c = reader.Read();
                if (c == -1)
                {
                    if (inQuotes) throw new InvalidDataException("CSV: 문자열 닫힘 누락");
                    if (sb.Length > 0 || row.Count > 0) { row.Add(sb.ToString()); result.Add(row.ToArray()); }
                    break;
                }

                char ch = (char)c;
                if (inQuotes)
                {
                    if (ch == '"')
                    {
                        int next = reader.Peek();
                        if (next == '"') { reader.Read(); sb.Append('"'); } // 이스케이프
                        else inQuotes = false;
                    }
                    else sb.Append(ch);
                }
                else
                {
                    if (ch == '"') inQuotes = true;
                    else if (ch == delimiter) { row.Add(sb.ToString()); sb.Clear(); }
                    else if (ch == '\n')
                    {
                        // CRLF/ LF 처리
                        if (sb.Length > 0 || row.Count > 0) { row.Add(sb.ToString()); sb.Clear(); result.Add(row.ToArray()); row.Clear(); }
                    }
                    else if (ch == '\r') { /* ignore */ }
                    else sb.Append(ch);
                }
            }

            return result;
        }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Editor\CardDataValidateMenu.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Editor\CardDataValidateMenu.cs.Extension)
#if UNITY_EDITOR
using System.Linq;
using SD.DataTable;
using SD.Gameplay.Cards.Infrastructure.Csv; // CsvCardRepository(TextAsset csv) 사용
using UnityEditor;
using UnityEngine;

public static class CardDataValidateMenu
{
    [MenuItem("SD/Data/Validate CardData.csv")]
    public static void Validate()
    {
        var config = FindConfigAsset();
        if (config == null || config.Tables == null || config.Tables.Count == 0)
        {
            Debug.LogError("[Validate] DataTableConfig을 찾지 못했거나 테이블이 비어있습니다. Tools > DataTables > Sync All 실행/Config 연결을 확인하세요.");
            return;
        }

        // 1) CardData 항목 하나를 찾는다
        var cardEntry = config.Tables.FirstOrDefault(
            t => string.Equals(t.Id, "CardData", System.StringComparison.OrdinalIgnoreCase));

        if (cardEntry.Csv == null)
        {
            Debug.LogError("[Validate] 'CardData' 항목을 찾지 못했거나 CSV가 비어있습니다.");
            return;
        }

        // 2) CsvCardRepository는 TextAsset 하나를 받으므로 그걸 넘긴다
        var repo = new CsvCardRepository(cardEntry.Csv); // ← 핵심 수정
        var ids = repo.All.Select(c => c.Id).ToList();

        if (ids.Count == 0)
        {
            Debug.LogWarning("[Validate] CardData가 0개로 로드되었습니다. Enabled/RowTypeName/CSV 내용을 확인하세요.");
        }
        else
        {
            Debug.Log($"CardData 유효성 OK. 총 {ids.Count}개\n- 상위 10개: {string.Join(", ", ids.Take(10))}");
        }
    }

    /// 프로젝트 전체에서 DataTableConfig를 찾아 테이블 수가 가장 많은 것을 선택
    private static DataTableConfig FindConfigAsset()
    {
        var guids = AssetDatabase.FindAssets("t:DataTableConfig");
        var assets = guids
            .Select(g => AssetDatabase.LoadAssetAtPath<DataTableConfig>(AssetDatabase.GUIDToAssetPath(g)))
            .Where(a => a != null)
            .ToList();

        if (assets.Count == 0) return null;
        if (assets.Count == 1) return assets[0];

        var chosen = assets.OrderByDescending(a => a.Tables?.Count ?? 0).First();
        var info = string.Join("\n - ", assets.Select(a => $"{AssetDatabase.GetAssetPath(a)} (Tables={a.Tables?.Count ?? 0})"));
        Debug.LogWarning($"[Validate] DataTableConfig가 여러 개입니다. 테이블이 가장 많은 에셋을 선택합니다.\n - 후보:\n - {info}\n - 선택: {AssetDatabase.GetAssetPath(chosen)}");
        return chosen;
    }
}
#endif
```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\GameBootstrap.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\GameBootstrap.cs.Extension)
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using SD.DataTable;                          // TableRegistry
using SD.Gameplay.Cards.Domain;             // CardDefinition
using SD.Gameplay.Cards.Infrastructure;     // CardFactory, CardCatalog

namespace SD.Gameplay.Cards.Infrastructure
{
    [DefaultExecutionOrder(-100)]
    /// <summary>
    /// 씬 시작 시 Registry에서 카드 테이블을 꺼내 CardDefinition으로 빌드하고 카탈로그에 등록.
    /// DataTableLoader(Awake)가 먼저 실행되어 TableRegistry에 세팅되어 있어야 한다.
    /// </summary>
    public sealed class GameBootstrap : MonoBehaviour
    {
        [SerializeField] private string _locale = "ko";  // "ko" or "en"
        [SerializeField] private CardCatalog _catalog;   // 씬에 없으면 자동 생성

        private void Awake()
        {
            // 1) DataTable에서 읽어온 IList들
            var rowsCard = TableRegistry.Get("CardData");
            var rowsName = TableRegistry.Get("CardName");
            var rowsDesc = TableRegistry.Get("CardDesc");

            Debug.Log($"[Bootstrap] tables: CardData={(rowsCard as System.Collections.ICollection)?.Count ?? 0}, " +
                      $"CardName={(rowsName as System.Collections.ICollection)?.Count ?? 0}, " +
                      $"CardDesc={(rowsDesc as System.Collections.ICollection)?.Count ?? 0}");

            // Null-safe: 없으면 빈 리스트로
            rowsCard ??= System.Array.Empty<object>();
            rowsName ??= System.Array.Empty<object>();
            rowsDesc ??= System.Array.Empty<object>();

            // 2) CardDefinition 빌드
            var cards = CardFactory.BuildAll(rowsCard, rowsName, rowsDesc, _locale);

            // 3) 카탈로그에 등록 (없으면 자동 생성)
            if (_catalog == null)
            {
                var go = new GameObject("CardCatalog");
                _catalog = go.AddComponent<CardCatalog>();
            }
            _catalog.Set(cards);



            Debug.Log($"[Bootstrap] CardCatalog ready: {cards.Count} cards");
        }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\SD.Gameplay.Cards.Infrastructure.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\SD.Gameplay.Cards.Infrastructure.asmdef.Extension)
{
    "name": "SD.Gameplay.Cards.Infrastructure",
    "rootNamespace": "",
    "references": [
        "SD.Gameplay.Cards.Domain",
        "SD.DataTable.Runtime",
        "SD.Core.Infrastructure"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}
```

## Assets\SDProject\Scripts\Gameplay\Cards\Presentation\SD.Gameplay.Cards.Presentation.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Presentation\SD.Gameplay.Cards.Presentation.asmdef.Extension)
{
  "name": "SD.Gameplay.Cards.Presentation",
  "references": [
    "SD.Gameplay.Cards.Domain",
    "SD.Core.Presentation"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Tools\Editor\AsmdefBootstrapper.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Tools\Editor\AsmdefBootstrapper.cs.Extension)
// File: Assets/SDProject/Scripts/Tools/Editor/AsmdefBootstrapper.cs
// 목적: 정식 구조용 asmdef 일괄 생성 (idempotent)
// 메뉴: SD/Bootstrap/Create asmdefs
#if UNITY_EDITOR
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace SD.Tools.Editor
{
    internal static class AsmdefBootstrapper
    {
        private const bool OverwriteExisting = true;

        // 경로 유틸
        private static string P(params string[] parts) => string.Join("/", parts);

        // 현재 스크립트의 경로를 기반으로 루트(Assets/***까지)를 자동 추출
        // 예: Assets/SDProject/Scripts/Tools/Editor/AsmdefBootstrapper.cs -> Assets/SDProject
        private static string DetectProjectRoot()
        {
            try
            {
                // 이 클래스 소스 에셋 검색
                var guids = AssetDatabase.FindAssets("AsmdefBootstrapper t:Script");
                foreach (var guid in guids)
                {
                    var path = AssetDatabase.GUIDToAssetPath(guid);
                    if (!path.EndsWith("AsmdefBootstrapper.cs", StringComparison.OrdinalIgnoreCase))
                        continue;

                    var idx = path.IndexOf("/Scripts/", StringComparison.Ordinal);
                    if (idx > 0)
                    {
                        var root = path.Substring(0, idx); // "Assets/SDProject"
                        if (root.StartsWith("Assets/", StringComparison.Ordinal))
                            return root;
                    }
                }
            }
            catch { /* no-op */ }

            // 폴백: 흔한 루트 후보
            var candidates = new[] { "Assets/SDProject", "Assets/_Project" };
            foreach (var c in candidates)
            {
                if (AssetDatabase.IsValidFolder(c))
                    return c;
            }

            throw new InvalidOperationException("프로젝트 루트를 찾을 수 없습니다. 'Assets/SDProject' 또는 'Assets/_Project' 중 하나를 생성하거나, 스크립트를 'Assets/<Root>/Scripts/.../AsmdefBootstrapper.cs'에 두세요.");
        }

        // asmdef JSON 모델
        [Serializable]
        private class AsmdefJson
        {
            public string name;
            public string[] references = Array.Empty<string>();
            public string[] includePlatforms = Array.Empty<string>();
            public string[] excludePlatforms = Array.Empty<string>();
            public bool allowUnsafeCode = false;
            public bool autoReferenced = true;
            public bool overrideReferences = false;
            public string[] precompiledReferences = Array.Empty<string>();
            public string[] defineConstraints = Array.Empty<string>();
            public bool noEngineReferences = false;
            public string[] optionalUnityReferences = Array.Empty<string>(); // tests
        }

        private class AsmdefSpec
        {
            public string Name;
            public string RelFolder;              // 루트(base)/ 하위 상대 경로 ("Scripts/Core/Domain" 등)
            public string[] References;
            public bool EditorOnly = false;
            public bool IsTestAssembly = false;
            public bool NoEngineRefs = false;
            public bool AutoReferenced = true;
        }

        // ====== 정의 목록 ======
        // 주의: 폴더는 "루트/RelFolder"로 생성됨. 루트는 DetectProjectRoot()로 자동 결정.
        private static readonly List<AsmdefSpec> _specs = new()
        {
            // Core
            new AsmdefSpec { Name = "SD.Core.Domain",          RelFolder = "Scripts/Core/Domain",          References = Array.Empty<string>(), NoEngineRefs = false },
            new AsmdefSpec { Name = "SD.Core.Infrastructure",  RelFolder = "Scripts/Core/Infrastructure",  References = new [] { "SD.Core.Domain" } },
            new AsmdefSpec { Name = "SD.Core.Presentation",    RelFolder = "Scripts/Core/Presentation",    References = new [] { "SD.Core.Domain", "SD.Core.Infrastructure", "Unity.TextMeshPro" } },

            // Gameplay.Cards
            new AsmdefSpec { Name = "SD.Gameplay.Cards.Domain",         RelFolder = "Scripts/Gameplay/Cards/Domain",         References = new [] { "SD.Core.Domain" } },
            new AsmdefSpec { Name = "SD.Gameplay.Cards.Infrastructure", RelFolder = "Scripts/Gameplay/Cards/Infrastructure", References = new [] { "SD.Gameplay.Cards.Domain", "SD.Core.Infrastructure" } },
            new AsmdefSpec { Name = "SD.Gameplay.Cards.Presentation",   RelFolder = "Scripts/Gameplay/Cards/Presentation",   References = new [] { "SD.Gameplay.Cards.Domain", "SD.Core.Presentation" } },

            // Gameplay.Battle
            new AsmdefSpec { Name = "SD.Gameplay.Battle.Domain",         RelFolder = "Scripts/Gameplay/Battle/Domain",         References = new [] { "SD.Core.Domain", "SD.Gameplay.Cards.Domain" } },
            new AsmdefSpec { Name = "SD.Gameplay.Battle.Infrastructure", RelFolder = "Scripts/Gameplay/Battle/Infrastructure", References = new [] { "SD.Gameplay.Battle.Domain", "SD.Core.Infrastructure" } },
            new AsmdefSpec { Name = "SD.Gameplay.Battle.Presentation",   RelFolder = "Scripts/Gameplay/Battle/Presentation",   References = new [] { "SD.Gameplay.Battle.Domain", "SD.Core.Presentation" } },

            // DataTables
            new AsmdefSpec { Name = "SD.DataTables.Runtime", RelFolder = "Scripts/DataTable/Runtime", References = new [] { "SD.Core.Domain", "Unity.Addressables" } },
            new AsmdefSpec { Name = "SD.DataTables.Editor",  RelFolder = "Scripts/DataTable/Editor",  References = new [] { "SD.DataTables.Runtime" }, EditorOnly = true },

            // UI / Tools
            new AsmdefSpec { Name = "SD.UI.Common",  RelFolder = "Scripts/UI/Common",  References = new [] { "SD.Core.Presentation", "Unity.TextMeshPro" } },
            new AsmdefSpec { Name = "SD.UI.Editor",  RelFolder = "Scripts/UI/Editor",  References = new [] { "SD.UI.Common" }, EditorOnly = true },
            new AsmdefSpec { Name = "SD.Tools.Editor", RelFolder = "Scripts/Tools/Editor", References = Array.Empty<string>(), EditorOnly = true },

            // Tests
            new AsmdefSpec {
                Name = "SD.Tests.EditMode",
                RelFolder = "Scripts/Core/Tests",
                References = new [] { "SD.Core.Domain", "SD.Core.Infrastructure" },
                EditorOnly = true, IsTestAssembly = true
            },
            new AsmdefSpec {
                Name = "SD.Gameplay.Tests",
                RelFolder = "Scripts/Gameplay/Battle/Tests",
                References = new [] { "SD.Gameplay.Battle.Domain", "SD.Gameplay.Battle.Infrastructure", "SD.Core.Infrastructure", "SD.Gameplay.Cards.Domain" },
                EditorOnly = true, IsTestAssembly = true
            },
        };

        [MenuItem("SD/Bootstrap/Create asmdefs", priority = 10)]
        public static void CreateAsmdefs()
        {
            var baseRoot = DetectProjectRoot(); // ex) "Assets/SDProject"
            try
            {
                int created = 0, skipped = 0, overwritten = 0;

                foreach (var spec in _specs)
                {
                    var fullFolder = P(baseRoot, spec.RelFolder);
                    EnsureFolder(fullFolder);

                    var asmdefPath = P(fullFolder, $"{spec.Name}.asmdef");
                    var json = BuildJson(spec);

                    if (File.Exists(asmdefPath))
                    {
                        if (!OverwriteExisting)
                        {
                            skipped++;
                            continue;
                        }
                        var old = File.ReadAllText(asmdefPath, Encoding.UTF8);
                        if (old == json)
                        {
                            skipped++;
                            continue;
                        }
                        File.WriteAllText(asmdefPath, json, Encoding.UTF8);
                        overwritten++;
                    }
                    else
                    {
                        File.WriteAllText(asmdefPath, json, Encoding.UTF8);
                        created++;
                    }
                }

                AssetDatabase.Refresh();
                Debug.Log($"[AsmdefBootstrapper] Root='{baseRoot}' Done. created={created}, overwritten={overwritten}, skipped={skipped}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AsmdefBootstrapper] ERROR: {ex.Message}\n{ex.StackTrace}");
                throw;
            }
        }

        private static void EnsureFolder(string folderPath)
        {
            var parts = folderPath.Split(new[] { '/', '\\' }, StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length == 0 || parts[0] != "Assets")
                throw new InvalidOperationException($"경로는 'Assets/..'로 시작해야 합니다: {folderPath}");

            var current = "Assets";
            for (int i = 1; i < parts.Length; i++)
            {
                var next = P(current, parts[i]);
                if (!AssetDatabase.IsValidFolder(next))
                    AssetDatabase.CreateFolder(current, parts[i]);
                current = next;
            }
        }

        private static string BuildJson(AsmdefSpec spec)
        {
            var data = new AsmdefJson
            {
                name = spec.Name,
                references = spec.References?.Distinct().ToArray() ?? Array.Empty<string>(),
                includePlatforms = spec.EditorOnly ? new[] { "Editor" } : Array.Empty<string>(),
                excludePlatforms = Array.Empty<string>(),
                allowUnsafeCode = false,
                autoReferenced = spec.AutoReferenced,
                overrideReferences = false,
                precompiledReferences = Array.Empty<string>(),
                defineConstraints = Array.Empty<string>(),
                noEngineReferences = spec.NoEngineRefs,
                optionalUnityReferences = spec.IsTestAssembly ? new[] { "TestAssemblies" } : Array.Empty<string>()
            };

            var sb = new StringBuilder();
            void Arr(string key, IEnumerable<string> arr)
            {
                var list = arr?.ToArray() ?? Array.Empty<string>();
                sb.Append($"  \"{key}\": [");
                if (list.Length > 0)
                {
                    sb.Append("\n");
                    for (int i = 0; i < list.Length; i++)
                    {
                        sb.Append($"    \"{list[i]}\"");
                        if (i < list.Length - 1) sb.Append(",");
                        sb.Append("\n");
                    }
                    sb.Append("  ]");
                }
                else sb.Append("]");
            }

            sb.Append("{\n");
            sb.AppendFormat("  \"name\": \"{0}\",\n", Escape(data.name));
            Arr("references", data.references); sb.Append(",\n");
            Arr("includePlatforms", data.includePlatforms); sb.Append(",\n");
            Arr("excludePlatforms", data.excludePlatforms); sb.Append(",\n");
            sb.AppendFormat("  \"allowUnsafeCode\": {0},\n", data.allowUnsafeCode.ToString().ToLower());
            sb.AppendFormat("  \"autoReferenced\": {0},\n", data.autoReferenced.ToString().ToLower());
            sb.AppendFormat("  \"overrideReferences\": {0},\n", data.overrideReferences.ToString().ToLower());
            Arr("precompiledReferences", data.precompiledReferences); sb.Append(",\n");
            Arr("defineConstraints", data.defineConstraints); sb.Append(",\n");
            sb.AppendFormat("  \"noEngineReferences\": {0}", data.noEngineReferences.ToString().ToLower());
            if (data.optionalUnityReferences != null && data.optionalUnityReferences.Length > 0)
            {
                sb.Append(",\n");
                Arr("optionalUnityReferences", data.optionalUnityReferences);
            }
            sb.Append("\n}\n");
            return sb.ToString();
        }

        private static string Escape(string s) => s?.Replace("\\", "\\\\").Replace("\"", "\\\"") ?? "";
    }
}
#endif

```

## Assets\SDProject\Scripts\Tools\Editor\FolderTreeSnapshot.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Tools\Editor\FolderTreeSnapshot.cs.Extension)
#if UNITY_EDITOR
using System;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace SD.Tools.Editor
{
    public static class FolderTreeSnapshot
    {
        private const string DefaultRoot = "Assets/SDProject";
        private const string DefaultOut = "Assets/SDProject/Docs/folder-tree.txt";
        private const string PrefKey_Root = "SD.Status.FolderRoot";
        private const string PrefKey_Out = "SD.Status.FolderTreePath";

        [MenuItem("Tools/Project/Generate Folder Tree", priority = 2)]
        public static void GenerateFolderTreeFile()
        {
            var root = EditorPrefs.GetString(PrefKey_Root, DefaultRoot);
            var outRel = EditorPrefs.GetString(PrefKey_Out, DefaultOut);
            WriteTree(root, outRel);
        }

        [MenuItem("Tools/Project/Generate Status + Folder Tree", priority = 0)]
        public static void GenerateStatusAndTree()
        {
            try { StatusFileGenerator.Generate(); }
            catch (Exception ex) { Debug.LogError($"[Status] Generate failed: {ex.Message}"); }
            GenerateFolderTreeFile();
        }

        [PreferenceItem("SDProject")]
        public static void Prefs()
        {
            EditorGUILayout.Space(8);
            EditorGUILayout.LabelField("Folder Tree Snapshot", EditorStyles.boldLabel);

            var root = EditorPrefs.GetString(PrefKey_Root, DefaultRoot);
            var outRel = EditorPrefs.GetString(PrefKey_Out, DefaultOut);

            EditorGUILayout.BeginHorizontal();
            var nextRoot = EditorGUILayout.TextField("Root Folder", root);
            if (GUILayout.Button("Reset", GUILayout.Width(70))) nextRoot = DefaultRoot;
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            var nextOut = EditorGUILayout.TextField("Output Path", outRel);
            if (GUILayout.Button("Reset", GUILayout.Width(70))) nextOut = DefaultOut;
            EditorGUILayout.EndHorizontal();

            if (nextRoot != root) EditorPrefs.SetString(PrefKey_Root, nextRoot);
            if (nextOut != outRel) EditorPrefs.SetString(PrefKey_Out, nextOut);

            if (GUILayout.Button("Generate Folder Tree Now")) GenerateFolderTreeFile();
        }

        private static void WriteTree(string rootFolder, string outRelPath)
        {
            if (!AssetDatabase.IsValidFolder(rootFolder))
            {
                Debug.LogWarning($"[folder-tree] Root folder not found: {rootFolder}");
                return;
            }

            var outFull = Path.GetFullPath(outRelPath);
            Directory.CreateDirectory(Path.GetDirectoryName(outFull)!);

            var sb = new StringBuilder();
            sb.AppendLine(rootFolder + "/");
            Recurse(rootFolder, 1, sb);

            File.WriteAllText(outFull, sb.ToString(), new UTF8Encoding(false));
            File.WriteAllText(outFull, sb.ToString(), new UTF8Encoding(false));

            // ★ Unity에 강제 반영
            AssetDatabase.ImportAsset(outRelPath, ImportAssetOptions.ForceSynchronousImport | ImportAssetOptions.ForceUpdate);
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh(ImportAssetOptions.ForceUpdate);

            // ★ 풀 경로 로그
            Debug.Log($"[folder-tree] Wrote (rel): {outRelPath}");
            Debug.Log($"[folder-tree] Wrote (abs): {outFull}");
        }

        private static void Recurse(string folder, int depth, StringBuilder sb, int maxDepth = 12)
        {
            if (depth > maxDepth) return;
            string indent = new string(' ', depth * 2);

            foreach (var sf in AssetDatabase.GetSubFolders(folder).OrderBy(p => p, StringComparer.OrdinalIgnoreCase))
            {
                sb.AppendLine($"{indent}{Path.GetFileName(sf)}/");
                Recurse(sf, depth + 1, sb, maxDepth);
            }

            var files = AssetDatabase.FindAssets("", new[] { folder })
                        .Select(AssetDatabase.GUIDToAssetPath)
                        .Where(p => !AssetDatabase.IsValidFolder(p))
                        .Where(p => p.EndsWith(".asmdef", StringComparison.OrdinalIgnoreCase)
                                 || p.EndsWith(".asset", StringComparison.OrdinalIgnoreCase)
                                 || p.EndsWith(".csv", StringComparison.OrdinalIgnoreCase)
                                 || p.EndsWith(".xlsx", StringComparison.OrdinalIgnoreCase)
                                 || p.EndsWith(".cs", StringComparison.OrdinalIgnoreCase))
                        .OrderBy(p => p, StringComparer.OrdinalIgnoreCase);

            foreach (var f in files) sb.AppendLine($"{indent}- {Path.GetFileName(f)}");
        }
    }
}
#endif

```

## Assets\SDProject\Scripts\Tools\Editor\SD.Tools.Editor.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Tools\Editor\SD.Tools.Editor.asmdef.Extension)
{
  "name": "SD.Tools.Editor",
  "rootNamespace": "SD.Tools.Editor",
  "references": [
    "SD.DataTable.Runtime",
    "SD.Gameplay.Cards.Domain",
    "SD.UI.Common"
  ],
  "includePlatforms": ["Editor"],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "versionDefines": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Tools\Editor\StatusFileGenerator.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Tools\Editor\StatusFileGenerator.cs.Extension)
#if UNITY_EDITOR
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using SD.DataTable;

namespace SD.Tools.Editor
{
    public static class StatusFileGenerator
    {
        private const string DefaultOutputRelPath = "Assets/SDProject/Docs/SDProject_Status.md";
        private const string PrefKey_OutputPath = "SD.Status.OutputPath";

        [MenuItem("Tools/Project/Generate Status File", priority = 1)]
        public static void Generate()
        {
            var outputRel = EditorPrefs.GetString(PrefKey_OutputPath, DefaultOutputRelPath);
            var outputFull = Path.GetFullPath(outputRel);
            Directory.CreateDirectory(Path.GetDirectoryName(outputFull)!);

            var sb = new StringBuilder();
            string now = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");

            sb.AppendLine("# SDProject — Project Status");
            sb.AppendLine($"_Last updated: {now} (local)_\n");
            sb.AppendLine("## 1) Overview");
            sb.AppendLine("- Engine: **Unity 6000.2.7f2 (PC/2D)**");
            sb.AppendLine("- Version control: **Git**");
            sb.AppendLine("- Architecture: **Domain / Presentation / Infrastructure / DataTable** with asmdef boundaries.");
            sb.AppendLine("- Current focus: **Data pipeline (XLSX→CSV→Runtime)**, **DataTableConfig Auto-Sync**, folder/asmdef hygiene.\n");

            sb.AppendLine("## 2) Data Pipeline — Rules");
            sb.AppendLine("- Editor: **ExcelDataReader** 기반 **XLSX→CSV** 변환 (첫 번째 시트만, 출력 파일명 동일).");
            sb.AppendLine("- CSV 규약: **Row1=Columns / Row2=Types / Row3+=Data** (Row2 권장).");
            sb.AppendLine("- Runtime: **DataTableLoader(Awake) → TableRegistry** 등록 → 코드에서 `TableRegistry.Get<T>()` 접근.");
            sb.AppendLine("- Auto-Sync: `Assets/SDProject/DataTables/Csv` 변화 시 **DataTableConfig** 자동/수동 동기화 지원.\n");

            string csvDir = "Assets/SDProject/DataTables/Csv";
            var csvList = FindCsv(csvDir);
            sb.AppendLine("## 3) Current Data Tables (CSV)");
            if (csvList.Count == 0) sb.AppendLine("- (none found)");
            else foreach (var c in csvList) sb.AppendLine($"- {c}");
            sb.AppendLine();

            var cfgs = AssetDatabase.FindAssets("t:DataTableConfig")
                        .Select(g => AssetDatabase.LoadAssetAtPath<DataTableConfig>(AssetDatabase.GUIDToAssetPath(g)))
                        .Where(c => c != null).OrderBy(c => c.name, StringComparer.OrdinalIgnoreCase).ToList();

            sb.AppendLine("## 4) DataTableConfig Assets");
            if (cfgs.Count == 0) sb.AppendLine("- (none found)");
            else
            {
                foreach (var cfg in cfgs)
                {
                    sb.AppendLine($"- **{cfg.name}**  ({AssetDatabase.GetAssetPath(cfg)})  Enabled={(cfg.Enabled ? "true" : "false")}");
                    if (cfg.Tables != null && cfg.Tables.Count > 0)
                    {
                        foreach (var t in cfg.Tables)
                        {
                            var csvName = t.Csv ? AssetDatabase.GetAssetPath(t.Csv) : "(null)";
                            sb.AppendLine($"  - Id=`{t.Id}`  Csv=`{csvName}`  RowType=`{t.RowTypeName}`");
                        }
                    }
                    else sb.AppendLine("  - (no tables)");
                }
            }
            sb.AppendLine();

            sb.AppendLine("## 5) Assembly Definitions (under SDProject)");
            foreach (var a in FindAsmdefs("Assets/SDProject")) sb.AppendLine($"- {a}");
            sb.AppendLine();

            sb.AppendLine("## 6) Folder Tree Snapshot (Assets/SDProject)");
            sb.AppendLine("```");
            sb.AppendLine(BuildFolderTree("Assets/SDProject", 6));
            sb.AppendLine("```\n");

            sb.AppendLine("## 7) Open Tasks / Next Steps");
            sb.AppendLine("- [ ] Add/verify Row models & `[DataTableId]` attributes for new CSVs");
            sb.AppendLine("- [ ] Decide if Row2(types) should be required & enforce");
            sb.AppendLine("- [ ] Flags/bitfield parsing helpers for position/tag columns");
            sb.AppendLine("- [ ] Unit tests: CSV parsing, enum mapping, duplicate Id detection\n");

            // Changelog append
            string prev = File.Exists(outputFull) ? File.ReadAllText(outputFull, Encoding.UTF8) : string.Empty;
            if (!prev.Contains("## 8) Changelog")) sb.AppendLine("## 8) Changelog");
            else
            {
                var idx = prev.IndexOf("## 8) Changelog", StringComparison.Ordinal);
                sb.Append(prev.Substring(idx));
            }
            sb.AppendLine($"\n- {now}: Status file regenerated.");

            File.WriteAllText(outputFull, sb.ToString(), new UTF8Encoding(false));
            // 파일 쓰기
            File.WriteAllText(outputFull, sb.ToString(), new UTF8Encoding(false));

            // ★ Unity에 강제 반영
            AssetDatabase.ImportAsset(outputRel, ImportAssetOptions.ForceSynchronousImport | ImportAssetOptions.ForceUpdate);
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh(ImportAssetOptions.ForceUpdate);

            // ★ 풀 경로까지 로그로 찍기(경로 혼동 방지)
            Debug.Log($"[Status] Generated (rel): {outputRel}");
            Debug.Log($"[Status] Generated (abs): {outputFull}");

        }

        [PreferenceItem("SDProject")]
        public static void PreferencesGUI()
        {
            EditorGUILayout.LabelField("Status File", EditorStyles.boldLabel);
            var curr = EditorPrefs.GetString(PrefKey_OutputPath, DefaultOutputRelPath);
            EditorGUILayout.BeginHorizontal();
            var next = EditorGUILayout.TextField("Output Path (relative)", curr);
            if (GUILayout.Button("Reset", GUILayout.Width(70))) next = DefaultOutputRelPath;
            EditorGUILayout.EndHorizontal();

            if (next != curr) EditorPrefs.SetString(PrefKey_OutputPath, next);
            EditorGUILayout.HelpBox("Recommended: Assets/SDProject/Docs/SDProject_Status.md", MessageType.Info);

            if (GUILayout.Button("Generate Now")) Generate();
        }

        private static List<string> FindCsv(string folder)
        {
            if (!AssetDatabase.IsValidFolder(folder)) return new();
            return AssetDatabase.FindAssets("t:TextAsset", new[] { folder })
                    .Select(AssetDatabase.GUIDToAssetPath)
                    .Where(p => p.EndsWith(".csv", StringComparison.OrdinalIgnoreCase))
                    .OrderBy(p => p, StringComparer.OrdinalIgnoreCase).ToList();
        }

        private static List<string> FindAsmdefs(string rootFolder)
        {
            if (!AssetDatabase.IsValidFolder(rootFolder)) return new();
            return AssetDatabase.FindAssets("t:TextAsset", new[] { rootFolder })
                    .Select(AssetDatabase.GUIDToAssetPath)
                    .Where(p => p.EndsWith(".asmdef", StringComparison.OrdinalIgnoreCase))
                    .OrderBy(p => p, StringComparer.OrdinalIgnoreCase).ToList();
        }

        private static string BuildFolderTree(string root, int maxDepth = 5)
        {
            if (!AssetDatabase.IsValidFolder(root)) return "(folder not found)";
            var sb = new StringBuilder();
            Recurse(root, 0);
            return sb.ToString();

            void Recurse(string folder, int depth)
            {
                if (depth > maxDepth) return;
                string indent = new string(' ', depth * 2);
                sb.AppendLine($"{indent}{Path.GetFileName(folder)}/");

                foreach (var sf in AssetDatabase.GetSubFolders(folder).OrderBy(p => p, StringComparer.OrdinalIgnoreCase))
                    Recurse(sf, depth + 1);

                var files = AssetDatabase.FindAssets("", new[] { folder })
                              .Select(AssetDatabase.GUIDToAssetPath)
                              .Where(p => !AssetDatabase.IsValidFolder(p))
                              .Where(p => p.EndsWith(".asmdef") || p.EndsWith(".asset") || p.EndsWith(".csv") || p.EndsWith(".xlsx") || p.EndsWith(".cs"))
                              .OrderBy(p => p, StringComparer.OrdinalIgnoreCase);
                foreach (var f in files) sb.AppendLine($"{indent}  - {Path.GetFileName(f)}");
            }
        }
    }
}
#endif

```

## Assets\SDProject\Scripts\UI\Common\SD.UI.Common.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\UI\Common\SD.UI.Common.asmdef.Extension)
{
  "name": "SD.UI.Common",
  "rootNamespace": "SD.UI.Common",
  "references": [
    "SD.Gameplay.Cards.Domain"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "versionDefines": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\UI\Editor\SD.UI.Editor.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\UI\Editor\SD.UI.Editor.asmdef.Extension)
{
  "name": "SD.UI.Editor",
  "references": [
    "SD.UI.Common"
  ],
  "includePlatforms": [
    "Editor"
  ],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

