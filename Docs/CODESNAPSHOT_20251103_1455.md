# Code Snapshot - 2025-11-03 14:55:45
Commit: e0e99d6

## Assets\SDProject\Scripts\Core\Domain\SD.Core.Domain.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Core\Domain\SD.Core.Domain.asmdef.Extension)
{
  "name": "SD.Core.Domain",
  "references": [],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Core\Infrastructure\SD.Core.Infrastructure.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Core\Infrastructure\SD.Core.Infrastructure.asmdef.Extension)
{
  "name": "SD.Core.Infrastructure",
  "references": [
    "SD.Core.Domain"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Core\Presentation\SD.Core.Presentation.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Core\Presentation\SD.Core.Presentation.asmdef.Extension)
{
  "name": "SD.Core.Presentation",
  "references": [
    "SD.Core.Domain",
    "SD.Core.Infrastructure",
    "Unity.TextMeshPro"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Core\Tests\SD.Tests.EditMode.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Core\Tests\SD.Tests.EditMode.asmdef.Extension)
{
  "name": "SD.Tests.EditMode",
  "references": [
    "SD.Core.Domain",
    "SD.Core.Infrastructure"
  ],
  "includePlatforms": [
    "Editor"
  ],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false,
  "optionalUnityReferences": [
    "TestAssemblies"
  ]
}

```

## Assets\SDProject\Scripts\DataTable\Editor\DataTableConfigAutoSync.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Editor\DataTableConfigAutoSync.cs.Extension)
#if UNITY_EDITOR
using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace SD.DataTable.Editor
{
    /// CSV 폴더를 스캔하여 모든 DataTableConfig의 _tables 배열을 동기화하고
    /// RowTypeName을 AssemblyQualifiedName으로 자동 채운다.
    /// - 우선순위: [DataTableId("Id")] > 관습(Id / IdRow / IdModel / IdDataModel)
    /// - 유일성 보장: 후보가 0개/2개 이상이면 채우지 않고 경고만 남긴다.
    /// - 메뉴 제공: Auto Sync 토글 / CSV 폴더 지정 / 전체 동기화 / 단일 Config 동기화
    public sealed class DataTableConfigAutoSync : AssetPostprocessor
    {
        private const string CsvFolderDefault = "Assets/SDProject/DataTables/Csv";
        private const string PrefKeyAutoSync = "SD.DataTable.AutoSync.Enabled";
        private const string PrefKeyCsvFolder = "SD.DataTable.CsvFolder";

        private static bool _isSyncInProgress;

        [InitializeOnLoadMethod]
        private static void Init()
        {
            if (!EditorPrefs.HasKey(PrefKeyAutoSync))
                EditorPrefs.SetBool(PrefKeyAutoSync, true);
            if (!EditorPrefs.HasKey(PrefKeyCsvFolder))
                EditorPrefs.SetString(PrefKeyCsvFolder, CsvFolderDefault);
        }

        [MenuItem("Tools/DataTables/Auto Sync Config", priority = 10)]
        private static void ToggleAutoSync()
        {
            bool now = EditorPrefs.GetBool(PrefKeyAutoSync, true);
            EditorPrefs.SetBool(PrefKeyAutoSync, !now);
            Debug.Log("[DataTable] Auto Sync: " + (!now ? "ON" : "OFF"));
        }

        [MenuItem("Tools/DataTables/Auto Sync Config", true)]
        private static bool ToggleAutoSyncValidate()
        {
            Menu.SetChecked("Tools/DataTables/Auto Sync Config", EditorPrefs.GetBool(PrefKeyAutoSync, true));
            return true;
        }

        [MenuItem("Tools/DataTables/Set CSV Folder...", priority = 11)]
        private static void SetCsvFolder()
        {
            string current = EditorPrefs.GetString(PrefKeyCsvFolder, CsvFolderDefault);
            string sel = EditorUtility.OpenFolderPanel("Select CSV Folder (under Assets)", current, "");
            if (string.IsNullOrEmpty(sel)) return;

            string proj = Application.dataPath.Substring(0, Application.dataPath.Length - "Assets".Length);
            if (!sel.StartsWith(proj))
            {
                Debug.LogError("선택한 폴더는 프로젝트 Assets 내부여야 합니다.");
                return;
            }

            string rel = sel.Substring(proj.Length).Replace('\\', '/');
            if (!rel.StartsWith("Assets/")) rel = "Assets/" + rel.TrimStart('/');

            if (!AssetDatabase.IsValidFolder(rel))
            {
                Debug.LogError("유효하지 않은 폴더: " + rel);
                return;
            }

            EditorPrefs.SetString(PrefKeyCsvFolder, rel);
            Debug.Log("[DataTable] CSV Folder: " + rel);
        }

        [MenuItem("Tools/DataTables/Sync All Configs Now", priority = 12)]
        private static void SyncAllNow()
        {
            string csvFolder = EditorPrefs.GetString(PrefKeyCsvFolder, CsvFolderDefault);
            SyncAllConfigs(csvFolder);
        }

        /// <summary>인스펙터 버튼에서 호출: 단일 Config만 동기화</summary>
        public static void SyncOneConfigNow(UnityEngine.ScriptableObject cfg)
        {
            if (cfg == null) return;

            string csvFolder = EditorPrefs.GetString(PrefKeyCsvFolder, CsvFolderDefault);
            if (!AssetDatabase.IsValidFolder(csvFolder))
            {
                Debug.LogWarning("[DataTable] CSV folder missing: " + csvFolder);
                return;
            }

            List<string> csvPaths = CollectCsvPaths(csvFolder);
            Dictionary<string, Type> byAttr, byName, byNameRow;
            BuildTypeIndexes(out byAttr, out byName, out byNameRow);

            int typed = 0;
            AssetDatabase.StartAssetEditing();
            try
            {
                ApplyToConfig(cfg, csvPaths, byAttr, byName, byNameRow, ref typed);
            }
            finally
            {
                AssetDatabase.StopAssetEditing();
                AssetDatabase.SaveAssets();
                AssetDatabase.Refresh();
            }

            Debug.Log("[DataTable] Sync '" + cfg.name + "' done. Typed: " + typed);
        }

        private static void OnPostprocessAllAssets(string[] imported, string[] deleted, string[] movedTo, string[] movedFrom)
        {
            if (!EditorPrefs.GetBool(PrefKeyAutoSync, true)) return;
            if (_isSyncInProgress) return;

            string csvFolder = EditorPrefs.GetString(PrefKeyCsvFolder, CsvFolderDefault);
            bool relevant =
                imported.Any(p => IsCsvUnder(p, csvFolder)) ||
                movedTo.Any(p => IsCsvUnder(p, csvFolder)) ||
                deleted.Any(p => IsCsvUnder(p, csvFolder)) ||
                movedFrom.Any(p => IsCsvUnder(p, csvFolder));

            if (relevant) SyncAllConfigs(csvFolder);
        }

        private static bool IsCsvUnder(string path, string root)
        {
            return path.StartsWith(root, StringComparison.OrdinalIgnoreCase) &&
                   path.EndsWith(".csv", StringComparison.OrdinalIgnoreCase);
        }

        private static void SyncAllConfigs(string csvFolder)
        {
            if (_isSyncInProgress) return;
            _isSyncInProgress = true;

            try
            {
                if (!AssetDatabase.IsValidFolder(csvFolder))
                {
                    Debug.LogWarning("[DataTable] CSV folder missing: " + csvFolder);
                    return;
                }

                // 1) 모든 DataTableConfig
                string[] cfgGuids = AssetDatabase.FindAssets("t:DataTableConfig");
                List<UnityEngine.ScriptableObject> cfgs = cfgGuids
                    .Select(g => AssetDatabase.LoadAssetAtPath<UnityEngine.ScriptableObject>(AssetDatabase.GUIDToAssetPath(g)))
                    .Where(c => c != null)
                    .ToList();
                if (cfgs.Count == 0) return;

                // 2) CSV 수집
                List<string> csvPaths = CollectCsvPaths(csvFolder);

                // 3) 타입 인덱스
                Dictionary<string, Type> byAttr, byName, byNameRow;
                BuildTypeIndexes(out byAttr, out byName, out byNameRow);

                // 4) 적용
                int totalEntries = 0, filledTypes = 0;
                AssetDatabase.StartAssetEditing();
                try
                {
                    foreach (var cfg in cfgs)
                        totalEntries += ApplyToConfig(cfg, csvPaths, byAttr, byName, byNameRow, ref filledTypes);
                }
                finally
                {
                    AssetDatabase.StopAssetEditing();
                    AssetDatabase.SaveAssets();
                    AssetDatabase.Refresh();
                }

                Debug.Log("[DataTable] Auto Sync complete → Configs: " + cfgs.Count + ", Tables: " + totalEntries + ", Typed: " + filledTypes);
            }
            finally
            {
                _isSyncInProgress = false;
            }
        }

        // --- Internals -------------------------------------------------------

        private static List<string> CollectCsvPaths(string csvFolder)
        {
            string[] csvGuids = AssetDatabase.FindAssets("t:TextAsset", new[] { csvFolder });
            List<string> list = csvGuids
                .Select(AssetDatabase.GUIDToAssetPath)
                .Where(p => p.EndsWith(".csv", StringComparison.OrdinalIgnoreCase))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .OrderBy(p => p, StringComparer.OrdinalIgnoreCase)
                .ToList();
            return list;
        }

        private static int ApplyToConfig(
            UnityEngine.ScriptableObject cfg,
            List<string> csvPaths,
            Dictionary<string, Type> byAttr,
            Dictionary<string, Type> byName,
            Dictionary<string, Type> byNameRow,
            ref int filledTypes)
        {
            // DataTableConfig 구조를 SerializedObject로 접근:
            // - 리스트 필드명: "_tables"
            // - 각 요소: "Id"(string) / "Csv"(TextAsset) / "RowTypeName"(string)
            SerializedObject so = new SerializedObject(cfg);
            SerializedProperty listProp = so.FindProperty("_tables");
            if (listProp == null || !listProp.isArray)
            {
                Debug.LogWarning("[DataTable] " + _nameof(cfg) + " 에 '_tables' 배열이 없습니다. 스킵.");
                return 0;
            }

            listProp.ClearArray();
            int i = 0, localFilled = 0;

            for (int k = 0; k < csvPaths.Count; k++)
            {
                string p = csvPaths[k];
                TextAsset csv = AssetDatabase.LoadAssetAtPath<TextAsset>(p);
                string id = Path.GetFileNameWithoutExtension(p);

                string reason;
                Type rowType = ResolveRowTypeStrict(id, byAttr, byName, byNameRow, out reason);

                listProp.InsertArrayElementAtIndex(i);
                SerializedProperty elem = listProp.GetArrayElementAtIndex(i);
                i++;

                SerializedProperty idProp = elem.FindPropertyRelative("Id");
                if (idProp != null) idProp.stringValue = id;

                SerializedProperty csvProp = elem.FindPropertyRelative("Csv");
                if (csvProp != null) csvProp.objectReferenceValue = csv;

                SerializedProperty rtypeProp = elem.FindPropertyRelative("RowTypeName");
                if (rowType != null)
                {
                    if (rtypeProp != null) rtypeProp.stringValue = rowType.AssemblyQualifiedName;
                    localFilled++;
                    if (reason != "attribute")
                        Debug.Log("[DataTable] RowTypeName set by convention: Id='" + id + "' → " + rowType.FullName);
                }
                else
                {
                    if (rtypeProp != null) rtypeProp.stringValue = string.Empty;
                    string msg = (reason == "no-match")
                        ? "No type found for Id '" + id + "'. Row 타입에 [SD.DataTable.DataTableId(\"" + id + "\")] 특성을 부여(권장)하거나, 클래스명을 '" + id + "', '" + id + "Row', '" + id + "Model', '" + id + "DataModel' 중 하나로 맞추세요."
                        : "Multiple candidate types for Id '" + id + "' → " + reason + ". 특성 [SD.DataTable.DataTableId(\"" + id + "\")]으로 명시해 주세요.";
                    Debug.LogWarning("[DataTable] " + msg + " (Config: " + cfg.name + ")");
                }
            }

            so.ApplyModifiedProperties();
            EditorUtility.SetDirty(cfg);
            filledTypes += localFilled;
            return i;

            // local helper
            static string _nameof(UnityEngine.Object o) { return o != null ? o.name : "(null)"; }
        }

        private static Type ResolveRowTypeStrict(
            string id,
            Dictionary<string, Type> byAttr,
            Dictionary<string, Type> byName,
            Dictionary<string, Type> byNameRow,
            out string reason)
        {
            // 1) 특성 우선
            Type viaAttr;
            if (byAttr.TryGetValue(id, out viaAttr)) { reason = "attribute"; return viaAttr; }

            // 2) 관습 후보 수집
            List<Type> candidates = new List<Type>();
            Type t0;
            if (byName.TryGetValue(id, out t0)) candidates.Add(t0);
            Type t1;
            if (byNameRow.TryGetValue(id, out t1)) candidates.Add(t1);
            Type t2;
            if (byName.TryGetValue(id + "Model", out t2)) candidates.Add(t2);
            Type t3;
            if (byName.TryGetValue(id + "DataModel", out t3)) candidates.Add(t3);

            // 유일성 판단
            List<Type> distinct = candidates.Distinct().ToList();
            if (distinct.Count == 1) { reason = "convention"; return distinct[0]; }

            if (distinct.Count == 0) reason = "no-match";
            else reason = "ambiguous: " + string.Join(", ", distinct.Select(x => x.FullName));
            return null;
        }

        private static void BuildTypeIndexes(
            out Dictionary<string, Type> byAttribute,
            out Dictionary<string, Type> byName,
            out Dictionary<string, Type> byNameRow)
        {
            byAttribute = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
            byName = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
            byNameRow = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);

            foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
            {
                string n = asm.GetName().Name;
                // 시스템계열만 배제, SD.* / 게임용 asmdef 전부 포함
                if (n.StartsWith("Unity") || n.StartsWith("System") || n.StartsWith("mscorlib") || n.StartsWith("netstandard"))
                    continue;

                Type[] types;
                try { types = asm.GetTypes(); }
                catch { continue; }

                for (int i = 0; i < types.Length; i++)
                {
                    Type t = types[i];
                    if (!t.IsClass || t.IsAbstract) continue;

                    // 1) [DataTableId("CardData")] 같은 특성이 있으면 최우선 키로 등록
                    SD.DataTable.DataTableIdAttribute attr =
                        (SD.DataTable.DataTableIdAttribute)Attribute.GetCustomAttribute(t, typeof(SD.DataTable.DataTableIdAttribute));
                    if (attr != null && !string.IsNullOrWhiteSpace(attr.Id))
                        byAttribute[attr.Id] = t;

                    // 2) 클래스명 그대로 매칭 (CardData, CardName, CardDesc ...)
                    byName[t.Name] = t;

                    // 3) 클래스명이 {Id}Row 형태면 {Id} 키로 등록 (CardDataRow → "CardData")
                    if (t.Name.EndsWith("Row", StringComparison.OrdinalIgnoreCase))
                    {
                        string key = t.Name.Substring(0, t.Name.Length - "Row".Length);
                        if (!string.IsNullOrWhiteSpace(key))
                            byNameRow[key] = t;
                    }
                }
            }
        }
    }

    // SerializedProperty 편의 확장
    internal static class SerializedPropertyExt
    {
        public static void SetString(this SerializedProperty p, string v) { if (p != null) p.stringValue = v; }
        public static void SetObject(this SerializedProperty p, UnityEngine.Object o) { if (p != null) p.objectReferenceValue = o; }
    }
}
#endif
```

## Assets\SDProject\Scripts\DataTable\Editor\DataTableConfigInspector.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Editor\DataTableConfigInspector.cs.Extension)
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;
using SD.DataTable;

[CustomEditor(typeof(SD.DataTable.DataTableConfig))]
public class DataTableConfigInspector : Editor
{
    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();

        GUILayout.Space(8);
        if (GUILayout.Button("Sync From Folder"))
        {
            ScriptableObject cfg = (ScriptableObject)target;
            SD.DataTable.Editor.DataTableConfigAutoSync.SyncOneConfigNow(cfg);
        }
    }
}
#endif
```

## Assets\SDProject\Scripts\DataTable\Editor\DataTableConfigSyncEditor.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Editor\DataTableConfigSyncEditor.cs.Extension)
#if UNITY_EDITOR
using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using SD.DataTable;

namespace SD.DataTable.Editor
{
    [CustomEditor(typeof(DataTableConfig))]
    public class DataTableConfigInspector : UnityEditor.Editor
    {
        private const string DefaultCsvFolder = "Assets/SDProject/DataTables/Csv";

        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();

            GUILayout.Space(8);
            EditorGUILayout.LabelField("Auto-Sync", EditorStyles.boldLabel);

            // 폴더 선택
            string folder = EditorPrefs.GetString("SD.DataTable.CsvFolder", DefaultCsvFolder);
            EditorGUI.BeginChangeCheck();
            folder = EditorGUILayout.TextField("CSV Folder", folder);
            if (EditorGUI.EndChangeCheck())
                EditorPrefs.SetString("SD.DataTable.CsvFolder", folder);

            using (new EditorGUI.DisabledScope(!AssetDatabase.IsValidFolder(folder)))
            {
                if (GUILayout.Button("Sync From Folder"))
                {
                    SyncFromFolder((DataTableConfig)target, folder);
                }
            }

            EditorGUILayout.HelpBox("CSV 파일명을 테이블 Id로 사용합니다. Row 타입은 [DataTableId] 또는 타입명 일치로 자동 매칭합니다.", MessageType.Info);
        }

        [MenuItem("Tools/DataTables/Sync Active DataTableConfig From Folder")]
        private static void MenuSyncActive()
        {
            var cfg = Selection.activeObject as DataTableConfig;
            if (cfg == null)
            {
                Debug.LogWarning("[DataTable] Select a DataTableConfig asset first.");
                return;
            }
            string folder = EditorPrefs.GetString("SD.DataTable.CsvFolder", DefaultCsvFolder);
            SyncFromFolder(cfg, folder);
        }

        private static void SyncFromFolder(DataTableConfig config, string folder)
        {
            if (!AssetDatabase.IsValidFolder(folder))
            {
                Debug.LogError($"[DataTable] Invalid folder: {folder}");
                return;
            }

            // 1) CSV 파일 수집
            var csvGuids = AssetDatabase.FindAssets("t:TextAsset", new[] { folder });
            var csvPaths = csvGuids.Select(AssetDatabase.GUIDToAssetPath)
                                   .Where(p => p.EndsWith(".csv", StringComparison.OrdinalIgnoreCase))
                                   .Distinct()
                                   .ToList();

            // 2) 타입 인덱스 빌드
            var rowTypes = FindRowTypes(); // IHasStringId 구현 타입들
            var byAttribute = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
            var byName = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);

            foreach (var t in rowTypes)
            {
                var attr = t.GetCustomAttribute<DataTableIdAttribute>();
                if (attr != null && !string.IsNullOrWhiteSpace(attr.Id))
                    byAttribute[attr.Id] = t;

                byName[t.Name] = t;
            }

            // 3) 새 목록 만들기
            var list = new List<DataTableConfig.TableEntry>();
            foreach (var p in csvPaths)
            {
                var csv = AssetDatabase.LoadAssetAtPath<TextAsset>(p);
                var id = Path.GetFileNameWithoutExtension(p); // 파일명 = Id

                Type rowType = null;
                if (byAttribute.TryGetValue(id, out var at)) rowType = at;
                else if (byName.TryGetValue(id, out var nt)) rowType = nt;

                var entry = new DataTableConfig.TableEntry
                {
                    Id = id,
                    Csv = csv,
                    RowTypeName = rowType != null
                        ? $"{rowType.FullName}, {rowType.Assembly.GetName().Name}"
                        : string.Empty
                };

                if (rowType == null)
                    Debug.LogWarning($"[DataTable] No row type matched for Id '{id}'. (Add [DataTableId(\"{id}\")] or rename the class to '{id}')");

                list.Add(entry);
            }

            // 4) 정렬/중복 정리
            list = list.OrderBy(e => e.Id, StringComparer.OrdinalIgnoreCase).ToList();

            // 5) 적용
            Undo.RecordObject(config, "Sync DataTableConfig");
            var so = new SerializedObject(config);
            var prop = so.FindProperty("_tables");
            prop.ClearArray();
            for (int i = 0; i < list.Count; i++)
            {
                prop.InsertArrayElementAtIndex(i);
                var elem = prop.GetArrayElementAtIndex(i);
                elem.FindPropertyRelative("Id").stringValue = list[i].Id;
                elem.FindPropertyRelative("Csv").objectReferenceValue = list[i].Csv;
                elem.FindPropertyRelative("RowTypeName").stringValue = list[i].RowTypeName ?? string.Empty;
            }
            so.ApplyModifiedProperties();
            EditorUtility.SetDirty(config);

            Debug.Log($"[DataTable] Sync complete. Tables: {list.Count}");
        }

        private static IEnumerable<Type> FindRowTypes()
        {
            var result = new List<Type>();
            foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())
            {
                // Unity/Editor 등 시스템 어셈블리 대량 건너뛰기(속도 최적화)
                var name = asm.GetName().Name;
                if (name.StartsWith("Unity")) continue;
                if (name.StartsWith("System")) continue;
                if (name.StartsWith("mscorlib")) continue;
                if (name.StartsWith("netstandard")) continue;

                Type iface = typeof(IHasStringId);
                Type attr = typeof(DataTableIdAttribute);

                try
                {
                    foreach (var t in asm.GetTypes())
                    {
                        if (!t.IsClass || t.IsAbstract) continue;
                        if (iface.IsAssignableFrom(t))
                            result.Add(t);
                    }
                }
                catch { /* 일부 동적 어셈블리 예외 무시 */ }
            }
            return result;
        }
    }
}
#endif
```

## Assets\SDProject\Scripts\DataTable\Editor\ExcelCodePagesInit.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Editor\ExcelCodePagesInit.cs.Extension)
#if UNITY_EDITOR
using System.Text;

namespace SD.DataTable.Editor
{
    [UnityEditor.InitializeOnLoad]
    internal static class ExcelCodePagesInit
    {
        static ExcelCodePagesInit()
        {

            Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
        }
    }
}
#endif

```

## Assets\SDProject\Scripts\DataTable\Editor\SD.DataTable.Editor.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Editor\SD.DataTable.Editor.asmdef.Extension)
{
  "name": "SD.DataTable.Editor",
  "references": [
    "SD.DataTable.Runtime"
  ],
  "includePlatforms": ["Editor"],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\DataTable\Editor\XlsxAssetPostprocessor.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Editor\XlsxAssetPostprocessor.cs.Extension)
#if UNITY_EDITOR
using System.IO;
using UnityEditor;

namespace SD.DataTable.Editor
{
    public sealed class XlsxAssetPostprocessor : AssetPostprocessor
    {
        private const string XlsxDir = "Assets/SDProject/DataTables/Xlsx";
        private const string CsvDir = "Assets/SDProject/DataTables/Csv";

        // 자산 임포트/변경/이동 감지 시 자동 변환
        static void OnPostprocessAllAssets(string[] imported, string[] deleted, string[] movedTo, string[] movedFrom)
        {
            bool any = false;

            void TryConvert(string assetPath)
            {
                if (!assetPath.EndsWith(".xlsx", System.StringComparison.OrdinalIgnoreCase)) return;
                if (!assetPath.StartsWith(XlsxDir)) return;

                var fullIn = Path.GetFullPath(assetPath);
                var fullOut = Path.GetFullPath(CsvDir);

                try
                {
                    XlsxToCsvConverter.ConvertXlsxToCsvFiles(fullIn, fullOut);
                    any = true;
                }
                catch (System.Exception ex)
                {
                    UnityEngine.Debug.LogError($"[XLSX→CSV] Convert failed: {assetPath}\n{ex.Message}");
                }
            }

            foreach (var p in imported) TryConvert(p);
            foreach (var p in movedTo) TryConvert(p);

            if (any)
            {
                AssetDatabase.Refresh();
            }
        }

        // 메뉴에서 수동 일괄 변환
        [MenuItem("Tools/DataTables/Convert All XLSX")]
        private static void ConvertAll()
        {
            if (!AssetDatabase.IsValidFolder(XlsxDir))
            {
                UnityEngine.Debug.LogWarning($"[XLSX→CSV] Missing folder: {XlsxDir}");
                return;
            }

            var guids = AssetDatabase.FindAssets("t:DefaultAsset", new[] { XlsxDir });
            int count = 0;
            foreach (var g in guids)
            {
                var path = AssetDatabase.GUIDToAssetPath(g);
                if (path.EndsWith(".xlsx"))
                {
                    try
                    {
                        XlsxToCsvConverter.ConvertXlsxToCsvFiles(Path.GetFullPath(path), Path.GetFullPath(CsvDir));
                        count++;
                    }
                    catch (System.Exception ex)
                    {
                        UnityEngine.Debug.LogError($"[XLSX→CSV] Convert failed: {path}\n{ex.Message}");
                    }
                }
            }
            AssetDatabase.Refresh();
            UnityEngine.Debug.Log($"[XLSX→CSV] Batch done. Converted files: {count}");
        }
    }
}
#endif

```

## Assets\SDProject\Scripts\DataTable\Editor\XlsxToCsvConverter.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Editor\XlsxToCsvConverter.cs.Extension)
#if UNITY_EDITOR
using System;
using System.IO;
using System.Text;
using ExcelDataReader; // NuGet: ExcelDataReader, ExcelDataReader.DataSet

namespace SD.DataTable.Editor
{
    internal static class XlsxToCsvConverter
    {
        // xlsx 파일 1개 → **첫 번째 시트만** CSV 1개로 출력
        // 출력 파일명: <xlsx파일명>.csv (예: CardData.xlsx → CardData.csv)
        public static void ConvertXlsxToCsvFiles(string xlsxFullPath, string outDir)
        {
            Directory.CreateDirectory(outDir);

            var fileName = Path.GetFileName(xlsxFullPath);
            if (string.IsNullOrEmpty(fileName) || fileName.StartsWith("~$"))
                return; // 임시/잠금파일 무시

            var csvOutPath = Path.Combine(outDir, $"{Path.GetFileNameWithoutExtension(xlsxFullPath)}.csv");

            using var stream = File.Open(xlsxFullPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
            using var reader = ExcelReaderFactory.CreateReader(stream);

            // 첫 번째 시트만 처리 (NextResult 호출 없음)
            int rowCount = 0;
            using var sw = new StreamWriter(csvOutPath, false, new UTF8Encoding(false)); // UTF-8 (no BOM)

            while (reader.Read())
            {
                rowCount++;
                int cellCount = reader.FieldCount;
                var line = new string[cellCount];

                for (int i = 0; i < cellCount; i++)
                {
                    var val = reader.GetValue(i)?.ToString() ?? string.Empty;
                    line[i] = CsvEscape(val);
                }
                sw.WriteLine(string.Join(",", line));
            }

            UnityEngine.Debug.Log($"[XLSX→CSV] {fileName} (Sheet#1 only) → {csvOutPath} ({rowCount} rows)");
        }

        private static string CsvEscape(string s)
        {
            bool needQuote = s.Contains(",") || s.Contains("\"") || s.Contains("\n") || s.Contains("\r");
            if (s.Contains("\"")) s = s.Replace("\"", "\"\"");
            return needQuote ? $"\"{s}\"" : s;
        }
    }
}
#endif
```

## Assets\SDProject\Scripts\DataTable\Runtime\CsvReader.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\CsvReader.cs.Extension)
using System.Collections.Generic;
using System.Text;

namespace SD.DataTable
{
    internal static class CsvReader
    {
        public static List<string[]> Parse(string text)
        {
            var result = new List<string[]>();
            if (string.IsNullOrEmpty(text)) return result;

            var row = new List<string>();
            var sb = new StringBuilder();
            bool inQuotes = false;

            for (int i = 0; i < text.Length; i++)
            {
                char c = text[i];
                if (inQuotes)
                {
                    if (c == '"')
                    {
                        if (i + 1 < text.Length && text[i + 1] == '"') { sb.Append('"'); i++; }
                        else inQuotes = false;
                    }
                    else sb.Append(c);
                }
                else
                {
                    if (c == '"') inQuotes = true;
                    else if (c == ',') { row.Add(sb.ToString()); sb.Clear(); }
                    else if (c == '\n')
                    {
                        row.Add(sb.ToString()); sb.Clear();
                        result.Add(row.ToArray()); row.Clear();
                    }
                    else if (c != '\r') sb.Append(c);
                }
            }
            row.Add(sb.ToString());
            result.Add(row.ToArray());
            return result;
        }
    }
}
```

## Assets\SDProject\Scripts\DataTable\Runtime\DataTableConfig.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\DataTableConfig.cs.Extension)
using System;
using System.Collections.Generic;
using UnityEngine;

namespace SD.DataTable
{
    [CreateAssetMenu(menuName = "SD/DataTableConfig")]
    public sealed class DataTableConfig : ScriptableObject
    {
        [Serializable]
        public struct TableEntry
        {
            public string Id;
            public TextAsset Csv;
            public string RowTypeName; // AssemblyQualifiedName
        }

        [SerializeField] private List<TableEntry> _tables = new();
        public IReadOnlyList<TableEntry> Tables => _tables;
    }
}
```

## Assets\SDProject\Scripts\DataTable\Runtime\DataTableIdAttribute.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\DataTableIdAttribute.cs.Extension)
using System;

namespace SD.DataTable
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public sealed class DataTableIdAttribute : Attribute
    {
        public string Id { get; }
        public DataTableIdAttribute(string id) => Id = id;
    }

}

```

## Assets\SDProject\Scripts\DataTable\Runtime\DataTableLoader.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\DataTableLoader.cs.Extension)
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace SD.DataTable
{
    /// <summary>
    /// CSV → RowType 파싱 → TableRegistry 등록.
    /// - RowTypeName 비어있는 항목은 "미사용 CSV"로 간주하여 조용히 스킵(옵션).
    /// - 에디터에선 Config SO 자동 바인딩(최다 테이블 보유 자산 1개).
    /// - 빈 줄/주석(#)/Enabled=false는 파싱 단계에서 제외.
    /// </summary>
    [DefaultExecutionOrder(-100)] // 부트스트랩보다 먼저 실행
    public sealed partial class DataTableLoader : MonoBehaviour
    {
        [Serializable]
        private struct TableEntry
        {
            public string Id;
            public TextAsset Csv;
            public string RowTypeName; // AssemblyQualifiedName (비면 '미사용 CSV'로 간주 가능)
        }

        [SerializeField] private bool _enabled = true;

        // 인스펙터에서 연결할 Config (Auto Sync로 채워진 SO)
        [SerializeField] private DataTableConfig _config;

        // (옵션) 수동 등록용 리스트: Config가 비어있을 때만 사용
        [SerializeField] private List<TableEntry> _tables = new();

        // ▼ 유연 스킵 모드: RowTypeName 비었으면 미사용 CSV로 간주해 조용히 스킵
        [Header("Unused Table Handling")]
        [SerializeField] private bool _treatEmptyRowTypeAsUnused = true; // 권장: true
        [SerializeField] private bool _warnOnUnusedTable = true;         // 스킵 시 경고 로그 남길지

        private void Awake()
        {
            if (!_enabled)
            {
                Debug.Log("[DataTable] Loader disabled (_enabled=false).");
                return;
            }

#if UNITY_EDITOR
            // 에디터에서 Config가 비어있으면 프로젝트 내에서 자동 탐색/바인딩(테이블 가장 많은 것)
            if (_config == null)
            {
                var cfg = FindBestConfigAsset();
                if (cfg != null)
                {
                    _config = cfg;
                    Debug.Log($"[DataTable] Auto-bound Config: {UnityEditor.AssetDatabase.GetAssetPath(cfg)} (Tables={cfg.Tables?.Count ?? 0})");
                }
                else
                {
                    Debug.LogWarning("[DataTable] No DataTableConfig asset found in project. Using local _tables.");
                }
            }
#endif

            LoadAll();
        }

        public void LoadAll()
        {
            // 우선순위: Config.Tables → _tables
            IEnumerable<(string Id, TextAsset Csv, string RowTypeName)> src;

            if (_config != null && _config.Tables != null && _config.Tables.Count > 0)
                src = _config.Tables.Select(t => (t.Id, t.Csv, t.RowTypeName));
            else
                src = _tables.Select(t => (t.Id, t.Csv, t.RowTypeName));

            var list = src.ToList();
            Debug.Log($"[DataTable] LoadAll source: Config={(_config != null ? "YES" : "NO")}, entries={list.Count}");

            int total = 0;
            foreach (var t in list)
            {
                try
                {
                    // 0) CSV 없음 → 조용히 스킵
                    if (t.Csv == null)
                    {
                        if (_warnOnUnusedTable)
                            Debug.LogWarning($"[DataTable] Load skipped: {t.Id} :: CSV is null");
                        continue;
                    }

                    // 1) RowTypeName 비었으면 '미사용 CSV'로 취급
                    if (string.IsNullOrWhiteSpace(t.RowTypeName))
                    {
                        if (_treatEmptyRowTypeAsUnused)
                        {
                            if (_warnOnUnusedTable)
                                Debug.LogWarning($"[DataTable] Skip(unused): {t.Id} :: RowTypeName empty");
                            continue; // 조용히 스킵
                        }
                        else
                        {
                            Debug.LogError(
                                $"[DataTable] Load skipped: {t.Id} :: RowTypeName is empty. " +
                                $"Tools > DataTables > Sync All Configs Now 또는 [DataTableId(\"{t.Id}\")]");
                            continue;
                        }
                    }

                    // 2) 타입 확인
                    var rowType = Type.GetType(t.RowTypeName, throwOnError: false);
                    if (rowType == null)
                    {
                        if (_treatEmptyRowTypeAsUnused && _warnOnUnusedTable)
                            Debug.LogWarning($"[DataTable] Skip(unresolved): {t.Id} :: Cannot resolve '{t.RowTypeName}'");
                        else
                            Debug.LogError($"[DataTable] Load failed: {t.Id} :: Cannot resolve type '{t.RowTypeName}'");
                        continue;
                    }

                    // 3) 파싱
                    var rows = BuildRows(t.Csv.text, rowType);

                    // 4) 전역 레지스트리에 등록
                    TableRegistry.Set(t.Id, rows);

                    var count = (rows as System.Collections.ICollection)?.Count ?? 0;
                    Debug.Log($"[DataTable] Loaded {t.Id} → {rowType.Name} ({count} rows)");
                    total += count;
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[DataTable] Load failed: {t.Id} :: {ex.Message}");
                }
            }

            if (total == 0)
                Debug.LogWarning("[DataTable] No rows loaded. Check Config reference and RowTypeName.");
        }

        /// <summary>
        /// CSV 텍스트를 rowType으로 매핑한 행 리스트를 반환한다.
        /// 반환 타입은 비제네릭 IList (List&lt;rowType&gt;를 박싱).
        /// - 빈 줄/주석(#...) 스킵
        /// - (존재 시) Id 공란 스킵
        /// - (존재 시) Enabled=false 스킵
        /// </summary>
        private static IList BuildRows(string csvText, Type rowType)
        {
            if (string.IsNullOrWhiteSpace(csvText))
                return (IList)Activator.CreateInstance(typeof(List<>).MakeGenericType(rowType));

            var lines = ReadCsv(csvText);
            if (lines.Count == 0)
                return (IList)Activator.CreateInstance(typeof(List<>).MakeGenericType(rowType));

            var header = lines[0].Select(h => h.Trim()).ToArray();
            var listType = typeof(List<>).MakeGenericType(rowType);
            var list = (IList)Activator.CreateInstance(listType);

            // 멤버 인덱스(헤더→프로퍼티/필드) 준비
            var members = CacheMembers(rowType, header);

            // 유효컬럼 인덱스 탐색(Id/Enabled)
            int idCol = Array.FindIndex(header, h => string.Equals(h, "Id", StringComparison.OrdinalIgnoreCase));
            int enCol = Array.FindIndex(header, h => string.Equals(h, "Enabled", StringComparison.OrdinalIgnoreCase));

            // --- 행 파싱 ---
            for (int r = 1; r < lines.Count; r++)
            {
                var cells = lines[r];
                int n = Math.Min(header.Length, cells.Length);

                // 0) 빈 줄 스킵
                bool allEmpty = true;
                for (int c = 0; c < n; c++)
                    if (!string.IsNullOrWhiteSpace(cells[c])) { allEmpty = false; break; }
                if (allEmpty) continue;

                // 1) 주석 줄 스킵: 첫 셀 "#..." 이면 무시
                if (n > 0 && cells[0].TrimStart().StartsWith("#")) continue;

                // 2) Id 빈 값 스킵 (Id 컬럼이 존재할 때만)
                if (idCol >= 0)
                {
                    var idText = idCol < cells.Length ? cells[idCol] : null;
                    if (string.IsNullOrWhiteSpace(idText)) continue;
                }

                // 3) Enabled=false 스킵 (Enabled 컬럼이 존재할 때만)
                if (enCol >= 0 && enCol < cells.Length)
                {
                    var s = cells[enCol]?.Trim();

                    // 공란을 true로 볼지 여부:
                    //   - 공란 = 활성(true)로 보려면 다음 줄의 주석을 해제
                    // if (string.IsNullOrWhiteSpace(s)) goto BUILD;

                    bool enabled = !string.IsNullOrEmpty(s) &&
                                   (s == "1" || s.Equals("true", StringComparison.OrdinalIgnoreCase) || s.Equals("yes", StringComparison.OrdinalIgnoreCase));
                    if (!enabled) continue;
                }

                // ---- 인스턴스 생성 & 멤버 매핑 ----
                var row = Activator.CreateInstance(rowType); // 기본 생성자 필요
                for (int c = 0; c < n; c++)
                {
                    var m = members[c];
                    if (m == null) continue;
                    var text = cells[c];

                    try
                    {
                        if (m is PropertyInfo pi)
                        {
                            if (!pi.CanWrite) continue;
                            var val = ConvertFromString(text, pi.PropertyType);
                            pi.SetValue(row, val);
                        }
                        else if (m is FieldInfo fi)
                        {
                            var val = ConvertFromString(text, fi.FieldType);
                            fi.SetValue(row, val);
                        }
                    }
                    catch (Exception e)
                    {
                        Debug.LogWarning($"[DataTable] Convert failed @ row {r + 1}, col {c + 1} ({header[c]}='{text}') → {e.Message}");
                    }
                }

                list.Add(row);
            }

            return list;
        }

        // --- Helpers ---------------------------------------------------------

        private static List<string[]> ReadCsv(string text)
        {
            var result = new List<string[]>();
            using var sr = new StringReader(text);

            var row = new List<string>();
            var sb = new System.Text.StringBuilder();
            bool inQuotes = false;

            while (true)
            {
                int c = sr.Read();
                if (c == -1)
                {
                    if (inQuotes) throw new InvalidDataException("CSV: unmatched quotes");
                    if (sb.Length > 0 || row.Count > 0)
                    {
                        row.Add(sb.ToString()); sb.Clear();
                        result.Add(row.ToArray()); row.Clear();
                    }
                    break;
                }

                char ch = (char)c;
                if (inQuotes)
                {
                    if (ch == '"')
                    {
                        int next = sr.Peek();
                        if (next == '"') { sr.Read(); sb.Append('"'); }
                        else inQuotes = false;
                    }
                    else sb.Append(ch);
                }
                else
                {
                    if (ch == '"') inQuotes = true;
                    else if (ch == ',') { row.Add(sb.ToString()); sb.Clear(); }
                    else if (ch == '\n') { row.Add(sb.ToString()); sb.Clear(); result.Add(row.ToArray()); row.Clear(); }
                    else if (ch == '\r') { /* ignore */ }
                    else sb.Append(ch);
                }
            }

            return result;
        }

        /// <summary>헤더 순서대로 매칭되는 멤버 캐시(없으면 null).</summary>
        private static MemberInfo[] CacheMembers(Type rowType, string[] header)
        {
            var flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.IgnoreCase;
            var props = rowType.GetProperties(flags).ToDictionary(p => p.Name, StringComparer.OrdinalIgnoreCase);
            var fields = rowType.GetFields(flags).ToDictionary(f => f.Name, StringComparer.OrdinalIgnoreCase);

            var result = new MemberInfo[header.Length];
            for (int i = 0; i < header.Length; i++)
            {
                var name = header[i];
                if (string.IsNullOrWhiteSpace(name)) { result[i] = null; continue; }

                if (props.TryGetValue(name, out var p)) result[i] = p;
                else if (fields.TryGetValue(name, out var f)) result[i] = f;
                else result[i] = null; // 매칭되는 멤버 없음
            }
            return result;
        }

        private static object ConvertFromString(string s, Type target)
        {
            if (target == typeof(string)) return s ?? string.Empty;
            if (target == typeof(int)) return int.TryParse(s, out var i) ? i : 0;
            if (target == typeof(float)) return float.TryParse(s, out var f) ? f : 0f;
            if (target == typeof(double)) return double.TryParse(s, out var d) ? d : 0d;
            if (target == typeof(bool)) return !string.IsNullOrEmpty(s) &&
                (s == "1" || s.Equals("true", StringComparison.OrdinalIgnoreCase) || s.Equals("yes", StringComparison.OrdinalIgnoreCase));

            if (target.IsEnum)
            {
                try { return Enum.Parse(target, s, ignoreCase: true); }
                catch { return Activator.CreateInstance(target); }
            }

            // Nullable<T>
            var u = Nullable.GetUnderlyingType(target);
            if (u != null)
            {
                if (string.IsNullOrWhiteSpace(s)) return null;
                return ConvertFromString(s, u);
            }

            // 기타 구조체/복합타입은 JSON으로 시도 (["..."], {"...":...} 형태)
            if (!string.IsNullOrWhiteSpace(s) && (s.StartsWith("{") || s.StartsWith("[")))
            {
                try
                {
                    // UnityEngine.JsonUtility는 루트 배열 미지원 → 래핑
                    if (s.StartsWith("["))
                    {
                        var wrapperType = typeof(Wrapper<>).MakeGenericType(target);
                        var json = "{\"Items\":" + s + "}";
                        var wrapper = JsonUtility.FromJson(json, wrapperType);
                        var itemsProp = wrapperType.GetField("Items");
                        return itemsProp?.GetValue(wrapper);
                    }
                    return JsonUtility.FromJson(s, target);
                }
                catch { /* ignore */ }
            }

            return target.IsValueType ? Activator.CreateInstance(target) : null;
        }

        [Serializable] private class Wrapper<T> { public T Items; }

#if UNITY_EDITOR
        // 에디터에서 Config 자동 탐색용
        private static SD.DataTable.DataTableConfig FindBestConfigAsset()
        {
            var guids = UnityEditor.AssetDatabase.FindAssets("t:DataTableConfig");
            var assets = guids
                .Select(g => UnityEditor.AssetDatabase.LoadAssetAtPath<SD.DataTable.DataTableConfig>(UnityEditor.AssetDatabase.GUIDToAssetPath(g)))
                .Where(a => a != null)
                .ToList();

            if (assets.Count == 0) return null;
            return assets.OrderByDescending(a => a.Tables?.Count ?? 0).First();
        }
#endif
    }
}
```

## Assets\SDProject\Scripts\DataTable\Runtime\ICsvTable.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\ICsvTable.cs.Extension)
using System.Collections.Generic;

namespace SD.DataTable
{
    public interface ICsvTable<TRow> where TRow : IHasStringId
    {
        IReadOnlyDictionary<string, TRow> ById { get; }
        IReadOnlyList<TRow> Rows { get; }
        bool TryGet(string id, out TRow row);
        TRow GetOrNull(string id);
    }
}

```

## Assets\SDProject\Scripts\DataTable\Runtime\IHasStringId.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\IHasStringId.cs.Extension)
namespace SD.DataTable
{
    public interface IHasStringId
    {
        string Id { get; }
    }
}

```

## Assets\SDProject\Scripts\DataTable\Runtime\ReflectionMapper.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\ReflectionMapper.cs.Extension)
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;

namespace SD.DataTable
{
    internal static class ReflectionMapper
    {
        public static T MapRow<T>(IReadOnlyDictionary<string, int> headerIndex, string[] row) where T : new()
        {
            var obj = new T();
            var t = typeof(T);
            foreach (var p in t.GetProperties(BindingFlags.Public | BindingFlags.Instance))
            {
                if (!p.CanWrite) continue;
                if (!headerIndex.TryGetValue(p.Name, out int c)) continue;
                if (c < 0 || c >= row.Length) continue;

                string cell = row[c]?.Trim() ?? "";
                p.SetValue(obj, ConvertCell(cell, p.PropertyType));
            }
            return obj;
        }

        private static object ConvertCell(string s, Type type)
        {
            if (type == typeof(string)) return s;
            if (type == typeof(bool)) return s.Equals("true", StringComparison.OrdinalIgnoreCase) || s == "1";
            if (type == typeof(int)) return int.TryParse(s, NumberStyles.Any, CultureInfo.InvariantCulture, out var i) ? i : 0;
            if (type == typeof(float)) return float.TryParse(s, NumberStyles.Any, CultureInfo.InvariantCulture, out var f) ? f : 0f;
            if (type == typeof(double)) return double.TryParse(s, NumberStyles.Any, CultureInfo.InvariantCulture, out var d) ? d : 0d;
            if (type.IsEnum)
            {
                try { return Enum.Parse(type, s, true); }
                catch { return Activator.CreateInstance(type)!; }
            }
            return Activator.CreateInstance(type)!;
        }
    }
}
```

## Assets\SDProject\Scripts\DataTable\Runtime\SD.DataTable.Runtime.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\SD.DataTable.Runtime.asmdef.Extension)
{
  "name": "SD.DataTable.Runtime",
  "references": [],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\DataTable\Runtime\Table.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\Table.cs.Extension)
using System.Collections.Generic;
using UnityEngine;

namespace SD.DataTable
{
    public class Table<TRow> : ICsvTable<TRow> where TRow : IHasStringId
    {
        private readonly Dictionary<string, TRow> _byId = new();
        private readonly List<TRow> _rows;

        public Table(List<TRow> rows)
        {
            _rows = rows ?? new List<TRow>();
            foreach (var r in _rows)
            {
                if (r == null || string.IsNullOrEmpty(r.Id))
                {
                    Debug.LogError($"[DataTable] Null/Empty Id in {typeof(TRow).Name}");
                    continue;
                }
                if (_byId.ContainsKey(r.Id))
                {
                    Debug.LogError($"[DataTable] Duplicate Id '{r.Id}' in {typeof(TRow).Name}");
                    continue;
                }
                _byId[r.Id] = r;
            }
        }

        public IReadOnlyDictionary<string, TRow> ById => _byId;
        public IReadOnlyList<TRow> Rows => _rows;
        public bool TryGet(string id, out TRow row) => _byId.TryGetValue(id, out row!);
        public TRow GetOrNull(string id) => _byId.TryGetValue(id, out var r) ? r : default!;
    }
}
```

## Assets\SDProject\Scripts\DataTable\Runtime\TableRegistry.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\DataTable\Runtime\TableRegistry.cs.Extension)
using System.Collections;
using System.Collections.Generic;

namespace SD.DataTable
{
    public static class TableRegistry
    {
        private static readonly Dictionary<string, IList> _tables = new();

        public static void Set(string id, IList rows)
        {
            if (string.IsNullOrWhiteSpace(id)) return;
            _tables[id] = rows ?? new List<object>();
        }

        public static IList Get(string id)
        {
            if (string.IsNullOrWhiteSpace(id)) return null;
            return _tables.TryGetValue(id, out var list) ? list : null;
        }

        public static IEnumerable<string> Keys => _tables.Keys;
        public static void Clear() => _tables.Clear();
    }
}
```

## Assets\SDProject\Scripts\Gameplay\Battle\Domain\CardInstance.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Domain\CardInstance.cs.Extension)
using SD.Gameplay.Cards.Domain;

namespace SD.Gameplay.Battle.Domain
{
    /// 전투 중 한 장의 카드 인스턴스(추후 고유 상태가 생길 수 있어 분리)
    public sealed class CardInstance
    {
        public string Id { get; }
        public CardDefinition Def { get; }

        public CardInstance(CardDefinition def)
        {
            Def = def;
            Id = def.Id;
        }

        public override string ToString() => Id;
    }

    public enum TurnSide { Player, Enemy }
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Domain\SD.Gameplay.Battle.Domain.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Domain\SD.Gameplay.Battle.Domain.asmdef.Extension)
{
  "name": "SD.Gameplay.Battle.Domain",
  "references": [
    "SD.DataTable.Runtime",
    "SD.Gameplay.Cards.Domain"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Domain\UnitDefinition.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Domain\UnitDefinition.cs.Extension)
using UnityEngine;

namespace SD.Gameplay.Battle.Domain
{
    /// 전투 유닛의 최소 정의(스폰용). 확장 필드는 이후 기획 확정 시 추가.
    public sealed class UnitDefinition
    {
        public string Id { get; }
        public string PrefabPath { get; }  // Resources 경로 (확정 전 Addressables 미도입)

        public UnitDefinition(string id, string prefabPath)
        {
            Id = id;
            PrefabPath = prefabPath;
        }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Domain\UnitRows.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Domain\UnitRows.cs.Extension)
using System;

namespace SD.Gameplay.Battle.Domain
{
    // Character.csv ↔ CharacterRow  (관습 매칭)
    public sealed class CharacterRow
    {
        public string Id;      // CSV: "Id"
        public string Prefab;  // CSV: "Prefab" (Resources 경로)
        public bool Enabled; // CSV: "Enabled" (없으면 false로 들어올 수 있음)
    }

    // Enemy.csv ↔ EnemyRow  (관습 매칭)
    public sealed class EnemyRow
    {
        public string Id;
        public string Prefab;
        public bool Enabled;
    }
}
```

## Assets\SDProject\Scripts\Gameplay\Battle\Infrastructure\BattleSystem.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Infrastructure\BattleSystem.cs.Extension)
using SD.Gameplay.Battle.Domain;
using UnityEngine;

namespace SD.Gameplay.Battle.Infrastructure
{
    /// 오케스트레이터: 전투 시작/입력 라우팅용
    public sealed class BattleSystem : MonoBehaviour
    {
        [SerializeField] private TurnController _turn;
        [SerializeField] private CardRuntimeRepository _repo;

        private void Reset()
        {
            if (_turn == null) _turn = FindAnyObjectByType<TurnController>();
            if (_repo == null) _repo = FindAnyObjectByType<CardRuntimeRepository>();
        }

        private void Awake()
        {
            if (_turn != null)
            {
                _turn.OnTurnStarted += side => Debug.Log($"[Battle] TurnStart: {side}");
                _turn.OnTurnEnded += side => Debug.Log($"[Battle] TurnEnd: {side}");
            }
            if (_repo != null)
            {
                _repo.OnHandChanged += _ => Debug.Log($"[Battle] Hand: {_repo.Hand.Count} cards");
                _repo.OnPileChanged += (d, c) => Debug.Log($"[Battle] Piles: Draw={d}, Discard={c}");
            }
        }

        private void Start() => _turn?.StartBattle();

        public void EndTurnButton() => _turn?.EndTurn();

        public bool TryPlayCard(int handIndex)
        {
            if (_repo == null) return false;
            if (handIndex < 0 || handIndex >= _repo.Hand.Count) return false;
            var inst = _repo.Hand[handIndex];
            var ok = _repo.TryPlay(inst);
            if (ok) Debug.Log($"[Battle] Played {inst.Id}");
            return ok;
        }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Infrastructure\CardRuntimeRepository.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Infrastructure\CardRuntimeRepository.cs.Extension)
using System;
using System.Collections.Generic;
using UnityEngine;
using SD.Gameplay.Cards.Domain;         // CardDefinition
using SD.Gameplay.Cards.Infrastructure; // CardCatalog

namespace SD.Gameplay.Battle.Infrastructure
{
    /// <summary>
    /// 덱/손패/버림패를 관리하는 최소 런타임 저장소.
    /// - InitDeckFromCatalog: 카탈로그에서 초기 덱 구성
    /// - StartPlayerTurn: 드로우
    /// - EndPlayerTurn: 손패 전부 버림
    /// - TryPlay: 손패에서 카드 1장 사용(버림으로 이동)
    /// - 이벤트: OnHandChanged, OnPileChanged
    /// </summary>
    public sealed class CardRuntimeRepository : MonoBehaviour
    {
        // ====== 모델 ======
        public sealed class CardInstance
        {
            public string Id;
            public CardDefinition Def;
            public CardInstance(CardDefinition def)
            {
                Def = def;
                Id = def?.Id ?? string.Empty;
            }
        }

        // ====== 설정 ======
        [SerializeField] private int _startHandCount = 5; // 전투 시작/턴 시작 시 손패 목표
        [SerializeField] private int _drawPerTurn = 5;    // 매 턴 시작 드로우 기본값

        // ====== 상태 ======
        private readonly List<CardInstance> _deck = new();
        private readonly List<CardInstance> _hand = new();
        private readonly List<CardInstance> _discard = new();

        public IReadOnlyList<CardInstance> Hand => _hand;

        // ====== 이벤트 ======
        /// <summary>손패 변경 시 호출: 현재 손패 스냅샷 전달</summary>
        public event Action<IReadOnlyList<CardInstance>> OnHandChanged;

        /// <summary>더미 수량 변경 시 호출: (Draw, Discard)</summary>
        public event Action<int, int> OnPileChanged;

        // ====== 초기화 ======
        /// <summary>
        /// 카탈로그에서 초기 덱을 구성한다. (현재는 간단 규칙: Enabled 카드 전부 → 섞어서 10장)
        /// 프로젝트 진행에 맞춰 덱 프리셋/세이브 연동으로 교체하면 됨.
        /// </summary>
        public void InitDeckFromCatalog()
        {
            _deck.Clear();
            _hand.Clear();
            _discard.Clear();

            var catalog = FindAnyObjectByType<CardCatalog>();
            if (catalog == null || catalog.All == null || catalog.All.Count == 0)
            {
                Debug.LogWarning("[Cards] CardCatalog not ready. Deck will be empty.");
                RaiseEvents();
                return;
            }

            // 간단 규칙: 사용 가능 카드 전부 수집 → 섞어서 10장 채용
            var pool = new List<CardDefinition>();
            foreach (var def in catalog.All)
            {
                if (def != null && def.Enabled) pool.Add(def);
            }
            if (pool.Count == 0)
            {
                Debug.LogWarning("[Cards] No enabled cards in catalog.");
                RaiseEvents();
                return;
            }

            Shuffle(pool);
            int take = Mathf.Min(10, pool.Count);
            for (int i = 0; i < take; i++) _deck.Add(new CardInstance(pool[i]));

            Shuffle(_deck);
            Debug.Log($"[Cards] Deck initialized: {_deck.Count} cards.");
            RaiseEvents();
        }

        // ====== 턴 제어 ======
        /// <summary>플레이어 턴 시작: 손패를 _drawPerTurn 장이 되도록 채우기.</summary>
        public void StartPlayerTurn()
        {
            int target = Mathf.Max(_drawPerTurn, _startHandCount);
            int need = Mathf.Max(0, target - _hand.Count);
            if (need > 0) Draw(need);
            RaiseEvents();
        }

        /// <summary>플레이어 턴 종료: 손패 전부 버림으로 이동.</summary>
        public void EndPlayerTurn()
        {
            DiscardAllHand();
            RaiseEvents();
        }

        // ====== 카드 사용 ======
        /// <summary>
        /// 손패에서 지정 카드를 사용. (v1: 효과 처리는 생략하고 버림으로만 이동)
        /// </summary>
        public bool TryPlay(CardInstance inst)
        {
            if (inst == null) return false;
            int idx = _hand.IndexOf(inst);
            if (idx < 0) return false;

            // 효과 처리 TODO: EffectResolver와 연결
            var used = _hand[idx];
            _hand.RemoveAt(idx);
            _discard.Add(used);

            // 사용 직후 즉시 보정하고 이벤트 발생
            RaiseEvents();
            return true;
        }

        // ====== 드로우/버림 ======
        public int Draw(int count)
        {
            int drawn = 0;
            for (int i = 0; i < count; i++)
            {
                if (_deck.Count == 0)
                {
                    // 리필: 버림 → 덱
                    if (_discard.Count == 0) break;
                    RefillDeckFromDiscard();
                }

                var top = _deck[_deck.Count - 1];
                _deck.RemoveAt(_deck.Count - 1);
                _hand.Add(top);
                drawn++;
            }
            return drawn;
        }

        public void DiscardAllHand()
        {
            if (_hand.Count == 0) return;
            _discard.AddRange(_hand);
            _hand.Clear();
        }

        private void RefillDeckFromDiscard()
        {
            _deck.AddRange(_discard);
            _discard.Clear();
            Shuffle(_deck);
        }

        // ====== 유틸 ======
        private void RaiseEvents()
        {
            OnHandChanged?.Invoke(_hand);
            OnPileChanged?.Invoke(_deck.Count, _discard.Count);
        }

        private static void Shuffle<T>(IList<T> list)
        {
            // UnityEngine.Random 기반의 간단 셔플
            for (int i = list.Count - 1; i > 0; i--)
            {
                int j = UnityEngine.Random.Range(0, i + 1);
                (list[i], list[j]) = (list[j], list[i]);
            }
        }
    }
}
```

## Assets\SDProject\Scripts\Gameplay\Battle\Infrastructure\PartySpawner.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Infrastructure\PartySpawner.cs.Extension)
using UnityEngine;
using SD.Gameplay.Battle.Domain;

namespace SD.Gameplay.Battle.Infrastructure
{
    /// 씬에 배치해서 아군/적군을 스폰한다.
    /// - PlayerRoot/EnemyRoot 아래에 차례로 배치
    /// - Prefab 경로가 없거나 로드 실패 시 플레이스홀더(스프라이트) 생성
    public sealed class PartySpawner : MonoBehaviour
    {
        [Header("Roots")]
        [SerializeField] private Transform _playerRoot; // Scenes/Battle/Parties/PlayerParty
        [SerializeField] private Transform _enemyRoot;  // Scenes/Battle/Parties/EnemyParty

        [Header("Visuals")]
        [SerializeField] private Vector2 _spacing = new Vector2(1.2f, 0f); // 가로 간격
        [SerializeField] private float _startXPlayer = -4f;
        [SerializeField] private float _startXEnemy = 4f;
        [SerializeField] private float _y = 0f; // 배치 y

        private void Reset()
        {
            var pr = transform.Find("PlayerRoot");
            var er = transform.Find("EnemyRoot");
            if (pr) _playerRoot = pr as Transform;
            if (er) _enemyRoot = er as Transform;
        }

        private void Start()
        {
            var cat = UnitCatalog.Instance;
            if (cat == null)
            {
                Debug.LogError("[PartySpawner] UnitCatalog.Instance is null. Ensure it exists in Boot or Battle scene.");
                return;
            }

            SpawnSide(cat.Players, _playerRoot, _startXPlayer, isEnemy: false);
            SpawnSide(cat.Enemies, _enemyRoot, _startXEnemy, isEnemy: true);
        }

        private void SpawnSide(System.Collections.Generic.IReadOnlyList<UnitDefinition> defs, Transform root, float startX, bool isEnemy)
        {
            if (root == null)
            {
                Debug.LogWarning($"[PartySpawner] Missing root for {(isEnemy ? "Enemy" : "Player")}.");
                return;
            }
            if (defs == null || defs.Count == 0) return;

            for (int i = 0; i < defs.Count; i++)
            {
                var def = defs[i];
                var go = TryInstantiate(def, root, isEnemy);
                // 좌→우 or 우→좌 정렬
                float x = startX + (isEnemy ? -i : i) * _spacing.x;
                go.transform.localPosition = new Vector3(x, _y, 0f);
                go.name = $"{(isEnemy ? "EN" : "PL")}_{def.Id}";
            }
        }

        private GameObject TryInstantiate(UnitDefinition def, Transform parent, bool isEnemy)
        {
            GameObject go = null;
            if (!string.IsNullOrWhiteSpace(def.PrefabPath))
            {
                var prefab = Resources.Load<GameObject>(def.PrefabPath);
                if (prefab != null)
                    go = Instantiate(prefab, parent);
                else
                    Debug.LogWarning($"[PartySpawner] Prefab not found: '{def.PrefabPath}' for '{def.Id}'. Using placeholder.");
            }

            if (go == null) go = CreatePlaceholder(parent, isEnemy);
            return go;
        }

        private static GameObject CreatePlaceholder(Transform parent, bool isEnemy)
        {
            var go = new GameObject("UnitPlaceholder");
            go.transform.SetParent(parent, worldPositionStays: false);

            var sr = go.AddComponent<SpriteRenderer>();
            sr.sprite = CreateQuadSprite();
            sr.color = isEnemy ? new Color(0.8f, 0.2f, 0.2f) : new Color(0.2f, 0.5f, 0.9f);
            go.transform.localScale = Vector3.one * 0.9f;
            return go;
        }

        // 간단한 1×1 사각형 스프라이트 생성(런타임 캐시)
        private static Sprite _quadSprite;
        private static Sprite CreateQuadSprite()
        {
            if (_quadSprite != null) return _quadSprite;
            var tex = new Texture2D(2, 2, TextureFormat.RGBA32, false);
            tex.SetPixels(new[] { Color.white, Color.white, Color.white, Color.white });
            tex.Apply();
            _quadSprite = Sprite.Create(tex, new Rect(0, 0, 2, 2), new Vector2(0.5f, 0.5f), 100f);
            _quadSprite.name = "RuntimeWhiteQuad";
            return _quadSprite;
        }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Infrastructure\SD.Gameplay.Battle.Infrastructure.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Infrastructure\SD.Gameplay.Battle.Infrastructure.asmdef.Extension)
{
  "name": "SD.Gameplay.Battle.Infrastructure",
  "references": [
    "SD.Gameplay.Battle.Domain",
    "SD.Gameplay.Cards.Domain",
    "SD.Gameplay.Cards.Infrastructure",
    "SD.Core.Domain",
    "SD.Core.Infrastructure",
    "SD.DataTable.Runtime"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Infrastructure\TurnController.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Infrastructure\TurnController.cs.Extension)
using System;
using UnityEngine;

namespace SD.Gameplay.Battle.Infrastructure
{
    public enum TurnSide { Player, Enemy }

    /// 간단 턴 컨트롤러: 플레이어 ↔ 적
    public sealed class TurnController : MonoBehaviour
    {
        [SerializeField] private CardRuntimeRepository _repo;

        public TurnSide CurrentSide { get; private set; } = TurnSide.Player;

        public event Action<TurnSide> OnTurnStarted;
        public event Action<TurnSide> OnTurnEnded;

        private void Reset()
        {
            if (_repo == null) _repo = FindAnyObjectByType<CardRuntimeRepository>();
        }

        public void StartBattle()
        {
            if (_repo == null)
            {
                Debug.LogError("[Turn] CardRuntimeRepository missing.");
                return;
            }

            _repo.InitDeckFromCatalog();

            CurrentSide = TurnSide.Player;
            OnTurnStarted?.Invoke(CurrentSide);
            _repo.StartPlayerTurn();
            Debug.Log("[Turn] Player turn started.");
        }

        public void EndTurn()
        {
            OnTurnEnded?.Invoke(CurrentSide);

            if (CurrentSide == TurnSide.Player)
            {
                _repo.EndPlayerTurn();

                CurrentSide = TurnSide.Enemy;
                OnTurnStarted?.Invoke(CurrentSide);
                Debug.Log("[Turn] Enemy turn started.");
                // TODO: 적 AI 행동
                CurrentSide = TurnSide.Player;
                OnTurnEnded?.Invoke(TurnSide.Enemy);

                OnTurnStarted?.Invoke(CurrentSide);
                _repo.StartPlayerTurn();
                Debug.Log("[Turn] Player turn started.");
            }
        }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Infrastructure\UnitCatalog.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Infrastructure\UnitCatalog.cs.Extension)
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;
using SD.Gameplay.Battle.Domain;

namespace SD.Gameplay.Battle.Infrastructure
{
    public sealed class UnitCatalog : MonoBehaviour
    {
        public static UnitCatalog Instance { get; private set; }

        [SerializeField] private string _characterTableId = "Character";
        [SerializeField] private string _enemyTableId = "Enemy";

        private readonly List<UnitDefinition> _players = new List<UnitDefinition>();
        private readonly List<UnitDefinition> _enemies = new List<UnitDefinition>();

        public IReadOnlyList<UnitDefinition> Players { get { return _players; } }
        public IReadOnlyList<UnitDefinition> Enemies { get { return _enemies; } }

        private void Awake()
        {
            if (Instance != null && Instance != this) { Destroy(gameObject); return; }
            Instance = this;
            DontDestroyOnLoad(gameObject);

            Build();
        }

        public void Build()
        {
            _players.Clear();
            _enemies.Clear();

            // 풀네임 호출 (using SD.DataTable 제거)
            IList chars = global::SD.DataTable.TableRegistry.Get(_characterTableId);
            IList enem = global::SD.DataTable.TableRegistry.Get(_enemyTableId);

            int pc = BuildList(chars, _players, _characterTableId);
            int ec = BuildList(enem, _enemies, _enemyTableId);

            Debug.Log("[Units] Catalog built → Players=" + pc + ", Enemies=" + ec);
        }

        private static int BuildList(IList rows, List<UnitDefinition> outList, string tableId)
        {
            if (rows == null)
            {
                Debug.LogWarning("[Units] Table '" + tableId + "' not found or unused.");
                return 0;
            }

            int added = 0;
            for (int i = 0; i < rows.Count; i++)
            {
                object row = rows[i];
                if (row == null) continue;

                string id = GetString(row, "Id");
                string prefab = GetString(row, "Prefab");

                if (string.IsNullOrWhiteSpace(id))
                {
                    Debug.LogWarning("[Units] " + tableId + " row#" + (i + 1) + ": empty Id -> skip");
                    continue;
                }

                if (string.IsNullOrWhiteSpace(prefab))
                {
                    Debug.LogWarning("[Units] " + tableId + " '" + id + "': Prefab empty -> will use placeholder");
                }

                outList.Add(new UnitDefinition(id, prefab));
                added++;
            }
            return added;
        }

        private static string GetString(object o, string member)
        {
            Type t = o.GetType();
            var pi = t.GetProperty(member, BindingFlags.Instance | BindingFlags.Public | BindingFlags.IgnoreCase);
            if (pi != null) { try { var v = pi.GetValue(o); return v != null ? v.ToString() : null; } catch { } }
            var fi = t.GetField(member, BindingFlags.Instance | BindingFlags.Public | BindingFlags.IgnoreCase);
            if (fi != null) { try { var v = fi.GetValue(o); return v != null ? v.ToString() : null; } catch { } }
            return null;
        }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Presentation\CardView.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Presentation\CardView.cs.Extension)
using System;
using TMPro;
using UnityEngine;
using UnityEngine.UI;
using SD.Gameplay.Cards.Domain; // CardDefinition

namespace SD.Gameplay.Battle.Presentation
{
    /// 카드 한 장의 UI 표현. 도메인 로직 없음(뷰 전용).
    public sealed class CardView : MonoBehaviour
    {
        [Header("Refs")]
        [SerializeField] private TMP_Text _title;
        [SerializeField] private TMP_Text _desc;
        [SerializeField] private TMP_Text _cost;
        [SerializeField] private Image _art;            // 선택(없어도 됨)
        [SerializeField] private Button _button;        // 클릭 캐스팅 MVP
        [SerializeField] private Image _frame;          // 카드 배경/테두리

        public CardDefinition Def { get; private set; }

        // 뷰 계층 이벤트 → 상위(HandView/BattleSystem)가 구독
        public event Action<CardView> OnClicked;

        private void Awake()
        {
            if (_button != null)
                _button.onClick.AddListener(() => OnClicked?.Invoke(this));
        }

        public void Bind(CardDefinition def)
        {
            Def = def;

            if (_title != null) _title.text = def.DisplayName ?? def.Id;
            if (_desc != null) _desc.text = def.DisplayDesc ?? string.Empty;
            if (_cost != null) _cost.text = def.Cost.ToString();

            // 아트/프레임은 현재 데이터 구조에 이미지 경로가 없으므로 보류(KISS).
            // 필요 시 이후 CardDefinition에 Sprite 참조 추가해서 연결.
        }

        public void SetInteractable(bool on)
        {
            if (_button != null) _button.interactable = on;
            if (_frame != null) _frame.color = on ? new Color(1, 1, 1, 0.9f) : new Color(1, 1, 1, 0.4f);
        }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Presentation\HandView.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Presentation\HandView.cs.Extension)
using System.Collections.Generic;
using UnityEngine;
using SD.Gameplay.Battle.Infrastructure;     // CardRuntimeRepository, BattleSystem

namespace SD.Gameplay.Battle.Presentation
{
    public sealed class HandView : MonoBehaviour
    {
        [Header("Bindings")]
        [SerializeField] private Transform _cardsRoot;
        [SerializeField] private CardView _cardPrefab;

        [Header("Sources (Optional: 자동 탐색)")]
        [SerializeField] private CardRuntimeRepository _repo;
        [SerializeField] private BattleSystem _battle;

        private readonly List<CardView> _spawned = new();

        private void Reset()
        {
            if (_cardsRoot == null)
            {
                var t = transform.Find("Cards");
                if (t != null) _cardsRoot = t;
            }
            if (_repo == null) _repo = FindAnyObjectByType<CardRuntimeRepository>();
            if (_battle == null) _battle = FindAnyObjectByType<BattleSystem>();
        }

        private void Awake()
        {
            if (_repo == null) _repo = FindAnyObjectByType<CardRuntimeRepository>();
            if (_battle == null) _battle = FindAnyObjectByType<BattleSystem>();
        }

        private void OnEnable()
        {
            if (_repo != null)
                _repo.OnHandChanged += Rebuild; // 시그니처가 정확히 일치해야 함
        }

        private void OnDisable()
        {
            if (_repo != null)
                _repo.OnHandChanged -= Rebuild;
        }

        // 🔧 핵심 수정: 파라미터 타입을 Repository의 중첩 타입으로 변경
        private void Rebuild(IReadOnlyList<CardRuntimeRepository.CardInstance> hand)
        {
            Clear();

            if (_cardsRoot == null || _cardPrefab == null || hand == null) return;

            for (int i = 0; i < hand.Count; i++)
            {
                var inst = hand[i];
                if (inst?.Def == null) continue;

                var view = Instantiate(_cardPrefab, _cardsRoot);
                view.Bind(inst.Def); // inst.Def 는 CardDefinition 이어야 함

                int index = i; // 클릭 시 플레이 요청 전달
                view.OnClicked += _ =>
                {
                    if (_battle != null)
                        _battle.TryPlayCard(index);
                };

                _spawned.Add(view);
            }
        }

        private void Clear()
        {
            foreach (var v in _spawned)
                if (v != null) Destroy(v.gameObject);
            _spawned.Clear();
        }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Presentation\PilesPanelView.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Presentation\PilesPanelView.cs.Extension)
using TMPro;
using UnityEngine;
using SD.Gameplay.Battle.Infrastructure;

namespace SD.Gameplay.Battle.Presentation
{
    /// 덱/버린패 개수 표시. Repository 이벤트 구독.
    public sealed class PilesPanelView : MonoBehaviour
    {
        [SerializeField] private TMP_Text _drawText;     // "Draw (..)"
        [SerializeField] private TMP_Text _discardText;  // "Discard (..)"
        [SerializeField] private CardRuntimeRepository _repo;

        private void Reset()
        {
            if (_repo == null) _repo = FindAnyObjectByType<CardRuntimeRepository>();
        }

        private void OnEnable()
        {
            if (_repo == null) _repo = FindAnyObjectByType<CardRuntimeRepository>();
            if (_repo != null)
            {
                _repo.OnPileChanged += OnPilesChanged;

                // 초기 표시는 비워두고, Repository에서 첫 이벤트가 올 때 갱신.
                // (원하면 아래 한 줄로 0,0 임시 표기 가능)
                OnPilesChanged(0, 0);
            }
        }

        private void OnDisable()
        {
            if (_repo != null)
                _repo.OnPileChanged -= OnPilesChanged;
        }

        private void OnPilesChanged(int draw, int discard)
        {
            if (_drawText) _drawText.text = $"Draw ({draw})";
            if (_discardText) _discardText.text = $"Discard ({discard})";
        }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Presentation\SD.Gameplay.Battle.Presentation.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Presentation\SD.Gameplay.Battle.Presentation.asmdef.Extension)
{
  "name": "SD.Gameplay.Battle.Presentation",
  "references": [
    "SD.Gameplay.Battle.Domain",
    "SD.Gameplay.Battle.Infrastructure",
    "SD.Gameplay.Cards.Domain",
    "Unity.TextMeshPro"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Gameplay\Battle\Tests\SD.Gameplay.Tests.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Battle\Tests\SD.Gameplay.Tests.asmdef.Extension)
{
  "name": "SD.Gameplay.Tests",
  "references": [
    "SD.Gameplay.Battle.Domain",
    "SD.Gameplay.Battle.Infrastructure",
    "SD.Core.Infrastructure",
    "SD.Gameplay.Cards.Domain"
  ],
  "includePlatforms": [
    "Editor"
  ],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false,
  "optionalUnityReferences": [
    "TestAssemblies"
  ]
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardDataModel.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardDataModel.cs.Extension)
using System;

namespace SD.Gameplay.Cards.Domain
{
    // !! SD.DataTable 특성 제거 !!  (AutoSync는 "CardDataModel", "CardData" 규칙으로 자동 매칭함)
    public sealed class CardDataModel
    {
        // CSV 헤더에 맞춰 필드 유지 (필요 없는 건 이후 정리)
        public string Id;
        public int Cost;

        public string Class;          // enum 매핑은 나중에 Factory에서 파싱
        public string Type;           // "
        public string Rarity;         // "
        public string Target;         // "

        public string UsePositions;   // 플래그/마스크면 int로 변경 가능
        public string HitPositions;   // "

        public string Tags;           // "A;B" 형태면 Factory에서 split
        public string Effects;        // JSON 문자열 (예: [{"type":"Damage","value":1}])

        public bool Enabled;        // 없으면 기본값 false 주의
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardDefinition.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardDefinition.cs.Extension)
using System.Collections.Generic;

namespace SD.Gameplay.Cards.Domain
{
    /// <summary>
    /// 런타임에서 카드 한 장을 표현하기 위한 최소 정의.
    /// CSV(CardData/Name/Desc)로부터 CardFactory가 생성한다.
    /// </summary>
    public sealed class CardDefinition
    {
        // 키/활성
        public string Id { get; set; }
        public bool Enabled { get; set; }

        // 로컬라이즈 키 & 결과
        public string NameId { get; set; }
        public string DescId { get; set; }
        public string DisplayName { get; set; }
        public string DisplayDesc { get; set; }

        // 기본 속성
        public CardType Type { get; set; }
        public CardClass Class { get; set; }      // Myth 단일화 반영
        public CardRarity Rarity { get; set; }
        public string CharId { get; set; }
        public int Cost { get; set; }

        public TargetType TargetType { get; set; }
        public PositionUseFlags PosUse { get; set; }
        public PositionHitFlags PosHit { get; set; }

        // 태그(자유 문자열; v1은 플래그 미사용)
        public List<string> Tags { get; set; } = new();

        // 효과(선택: 별도 모듈에서 해석/실행)
        public List<Effects.EffectSpec> Effects { get; set; } = new();

        // 업그레이드 메타
        public bool Upgradable { get; set; }
        public int UpgradeStep { get; set; }
        public string UpgradeRefId { get; set; }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardEffects.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardEffects.cs.Extension)
using System.Collections.Generic;

namespace SD.Gameplay.Cards.Domain
{
    public enum EffectType { Damage, Heal, Shield, Buff, Debuff, Knockback, Pull, Push }

    [System.Serializable]
    public class CardEffect
    {
        public EffectType Type;
        public int Value;
        public int Duration;
        public int Cells; // 위치 이동 계열
    }

    [System.Serializable]
    public class CardEffectArray { public List<CardEffect> Items = new(); }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardEnums.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\CardEnums.cs.Extension)
namespace SD.Gameplay.Cards.Domain
{
    public enum CardType { Unknown = 0, Attack = 1, Defense = 2, Support = 3, Move = 4 }

    public enum CardClass { Unknown = 0, Base = 1, Character = 2, Myth = 3 }

    public enum CardRarity { Unknown = 0, Common = 1, Rare = 2 }
    public enum TargetType { Unknown = 0, Self = 1, Ally = 2, AllyAll = 3, Enemy = 4, EnemyAll = 5, AllyThenEnemy = 6 }

    [System.Flags]
    public enum PositionUseFlags { None = 0, Front = 1 << 0, Mid1 = 1 << 1, Mid2 = 1 << 2, Back = 1 << 3 }

    [System.Flags]
    public enum PositionHitFlags { None = 0, Front = 1 << 0, Mid1 = 1 << 1, Mid2 = 1 << 2, Mid3 = 1 << 3, Back = 1 << 4 }

    [System.Flags]
    public enum CardTagFlags { None = 0 }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\Effects\EffectModel.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\Effects\EffectModel.cs.Extension)
using System.Collections.Generic;
using UnityEngine;

namespace SD.Gameplay.Cards.Domain.Effects
{
    /// <summary>
    /// 런타임에서 사용되는 표준 이펙트 포맷(정규화 결과).
    /// </summary>
    [System.Serializable]
    public struct EffectSpec
    {
        public string effect;   // "Damage" 만 사용(v1)
        public float value;     // 수치
        public float duration;  // 선택
        public string arg;      // 선택
    }

    // 입력 JSON을 받기 위한 "raw" 구조체 (type/effect 둘 다 허용)
    [System.Serializable]
    internal struct EffectSpecRaw
    {
        public string type;     // 예: "Damage"
        public string effect;   // 예: "Damage"
        public float value;
        public float duration;
        public string arg;

        public EffectSpec Normalize()
        {
            var eff = string.IsNullOrWhiteSpace(effect) ? type : effect;
            return new EffectSpec
            {
                effect = eff,
                value = value,
                duration = duration,
                arg = arg
            };
        }
    }

    // JsonUtility는 루트 배열을 직접 못 읽어서 래핑
    [System.Serializable]
    internal class EffectArrayWrapper { public EffectSpecRaw[] items; }

    public static class EffectJsonParser
    {
        /// <summary>
        /// 최소 동작: [{"type":"Damage","value":1}] 또는 [{"effect":"Damage","value":1}]
        /// - 허용: 배열/단일객체
        /// - "Damage" 외 타입은 무시
        /// - 파싱 실패 시 빈 리스트 반환(에러 대신 경고)
        /// </summary>
        public static List<EffectSpec> Parse(string json)
        {
            var list = new List<EffectSpec>();
            if (string.IsNullOrWhiteSpace(json)) return list;

            try
            {
                var trimmed = json.TrimStart();

                if (trimmed.StartsWith("["))
                {
                    // 배열 → 래핑
                    var wrapped = "{\"items\":" + json + "}";
                    var rawArr = JsonUtility.FromJson<EffectArrayWrapper>(wrapped);
                    if (rawArr?.items != null)
                    {
                        foreach (var r in rawArr.items)
                        {
                            var spec = r.Normalize();
                            if (IsSupported(spec)) list.Add(spec);
                        }
                    }
                }
                else
                {
                    // 단일 객체
                    var raw = JsonUtility.FromJson<EffectSpecRaw>(json);
                    var spec = raw.Normalize();
                    if (IsSupported(spec)) list.Add(spec);
                }
            }
            catch
            {
                Debug.LogWarning($"[Effect] Parse failed: {json}");
            }

            return list;
        }

        // v1에서는 Damage만 허용(나머지는 무시)
        private static bool IsSupported(EffectSpec spec)
            => !string.IsNullOrWhiteSpace(spec.effect) &&
               spec.effect.Equals("Damage", System.StringComparison.OrdinalIgnoreCase);
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\ICardRepository.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\ICardRepository.cs.Extension)
using System.Collections.Generic;

namespace SD.Gameplay.Cards.Domain
{
    public interface ICardRepository
    {
        bool TryGet(string id, out CardDataModel card);
        IEnumerable<CardDataModel> All { get; }
        int Count { get; }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\Localization\CardTextRows.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\Localization\CardTextRows.cs.Extension)
using System;

namespace SD.Gameplay.Cards.Domain.Localization
{
    // !! SD.DataTable 특성과 IHasStringId 제거 !!
    // AutoSync: "CardNameRow" → Id "CardName" 로 매칭, "CardDescRow" → "CardDesc" 로 매칭
    public sealed class CardNameRow
    {
        public string Id;   // 카드 키
        public string ko;   // 한국어
        public string en;   // 영어 (없으면 빈칸)
    }

    public sealed class CardDescRow
    {
        public string Id;
        public string ko;
        public string en;
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Domain\SD.Gameplay.Cards.Domain.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Domain\SD.Gameplay.Cards.Domain.asmdef.Extension)
{
  "name": "SD.Gameplay.Cards.Domain",
  "rootNamespace": "SD.Gameplay.Cards.Domain",
  "references": [
    "SD.DataTable.Runtime"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "versionDefines": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\CardCatalog.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\CardCatalog.cs.Extension)
using System.Collections.Generic;
using UnityEngine;
using SD.Gameplay.Cards.Domain;

namespace SD.Gameplay.Cards.Infrastructure
{
    /// <summary>런타임 카드 데이터 저장소(싱글톤).</summary>
    public sealed class CardCatalog : MonoBehaviour
    {
        public static CardCatalog Instance { get; private set; }
        private List<CardDefinition> _cards = new();
        public IReadOnlyList<CardDefinition> All => _cards;

        private void Awake()
        {
            if (Instance != null && Instance != this) { Destroy(gameObject); return; }
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }

        public void Set(List<CardDefinition> cards) => _cards = cards ?? new();

        public CardDefinition FindById(string id) =>
            _cards.Find(c => c.Id.Equals(id, System.StringComparison.OrdinalIgnoreCase));
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\CardFactory.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\CardFactory.cs.Extension)
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;
using SD.Gameplay.Cards.Domain;
using SD.Gameplay.Cards.Domain.Effects; // EffectJsonParser / EffectSpec

namespace SD.Gameplay.Cards.Infrastructure
{
    /// <summary>
    /// CSV 로우(IList)들을 묶어 CardDefinition 리스트를 생성.
    /// - 로컬라이즈 테이블(CardName/CardDesc)은 Ko/En 컬럼을 리플렉션으로 동적 탐색(강한 의존 제거)
    /// - 카드 데이터 필드(string/enum/flags/int) 관대 파싱
    /// - Effects: 최소 구현(Damage)만 지원
    /// </summary>
    public static class CardFactory
    {
        public static List<CardDefinition> BuildAll(
            IList cardDataRows,   // List<CardDataModel> as IList
            IList nameRows,       // List<*> as IList (Id + Ko/En 헤더만 있으면 됨)
            IList descRows,       // List<*> as IList (Id + Ko/En 헤더만 있으면 됨)
            string locale = null  // "ko"|"en" (null이면 시스템 언어)
        )
        {
            var result = new List<CardDefinition>();
            if (cardDataRows == null) return result;

            // 로컬라이즈 맵(리플렉션 기반 추출: Id/Ko/En 헤더만 맞으면 타입 무관)
            var nameMap = ToTextMap(nameRows);
            var descMap = ToTextMap(descRows);
            var lang = NormalizeLocale(locale);

            foreach (var row in cardDataRows.Cast<object>())
            {
                try
                {
                    var enabled = GetBool(row, true, "Enabled", "IsEnabled", "Enable");
                    if (!enabled) continue;

                    var id = GetString(row, "Id");
                    var nameId = GetString(row, "NameId", "NameID", "NameKey");
                    var descId = GetString(row, "DescId", "DescID", "DescKey", "DescriptionId");

                    var def = new CardDefinition
                    {
                        Id = id,
                        Enabled = enabled,

                        NameId = nameId,
                        DescId = descId,
                        DisplayName = ResolveText(nameMap, nameId, lang),
                        DisplayDesc = ResolveText(descMap, descId, lang),

                        Type = GetEnum<CardType>(row, "Type", CardType.Unknown),
                        Class = GetEnum<CardClass>(row, "Class", CardClass.Unknown, normalize: NormalizeClass),
                        Rarity = GetEnum<CardRarity>(row, "Rarity", CardRarity.Unknown),

                        CharId = GetString(row, "CharId", "CharacterId"),
                        Cost = GetInt(row, "Cost", 0),

                        TargetType = GetEnum<TargetType>(row, "TargetType", TargetType.Unknown),

                        PosUse = GetFlags<PositionUseFlags>(row, "PosUse", ParseUseFlags),
                        PosHit = GetFlags<PositionHitFlags>(row, "PosHit", ParseHitFlags),

                        Effects = EffectJsonParser.Parse(
                            FirstNonEmpty(
                                GetString(row, "EffectsJSON"),
                                GetString(row, "EffectsJson"),
                                GetString(row, "EffectsText"),
                                GetString(row, "Effects")
                            ) ?? string.Empty
                        ),

                        Upgradable = GetBool(row, true, "Upgradable", "Upgradeable", "IsUpgradable"),
                        UpgradeStep = GetInt(row, "UpgradeStep", 0),
                        UpgradeRefId = GetString(row, "UpgradeRefId", "UpgradeTo"),

                        Tags = GetTags(row, "Tags"),
                    };

                    if (string.IsNullOrWhiteSpace(def.DisplayName))
                        def.DisplayName = def.NameId; // 키 자체를 보여줘 디버깅 편의

                    result.Add(def);
                }
                catch (Exception ex)
                {
                    Debug.LogWarning($"[CardFactory] Skip row due to error: {ex.Message}");
                }
            }

            return result;
        }

        // -------------------- 리플렉션 헬퍼 --------------------
        static readonly BindingFlags _bf = BindingFlags.Instance | BindingFlags.Public | BindingFlags.IgnoreCase;

        static MemberInfo FindMember(object obj, params string[] names)
        {
            var t = obj.GetType();
            foreach (var n in names)
            {
                var p = t.GetProperty(n, _bf);
                if (p != null) return p;
                var f = t.GetField(n, _bf);
                if (f != null) return f;
            }
            return null;
        }

        static object GetRaw(object obj, params string[] names)
        {
            var m = FindMember(obj, names);
            if (m == null) return null;
            return m is PropertyInfo pi ? pi.GetValue(obj) : ((FieldInfo)m).GetValue(obj);
        }

        static string GetString(object obj, params string[] names)
        {
            foreach (var n in names)
            {
                var v = GetRaw(obj, n);
                if (v == null) continue;
                if (v is string s) return s;
                return v.ToString();
            }
            return string.Empty;
        }

        static int GetInt(object obj, string name, int def = 0)
        {
            var v = GetRaw(obj, name);
            if (v == null) return def;
            if (v is int i) return i;
            if (int.TryParse(v.ToString(), out var p)) return p;
            return def;
        }

        static bool GetBool(object obj, bool def, params string[] names)
        {
            foreach (var name in names)
            {
                var v = GetRaw(obj, name);
                if (v == null) continue;
                if (v is bool b) return b;

                var s = v.ToString();
                if (bool.TryParse(s, out var pb)) return pb;
                if (int.TryParse(s, out var pi)) return pi != 0;
                if (s.Equals("yes", StringComparison.OrdinalIgnoreCase)) return true;
                if (s.Equals("no", StringComparison.OrdinalIgnoreCase)) return false;
            }
            return def;
        }

        static TEnum GetEnum<TEnum>(object obj, string name, TEnum def, Func<string, string> normalize = null) where TEnum : struct
        {
            var v = GetRaw(obj, name);
            if (v == null) return def;

            if (v is TEnum e) return e;

            if (v is IConvertible)
            {
                try
                {
                    var i = Convert.ToInt32(v);
                    if (Enum.IsDefined(typeof(TEnum), i))
                        return (TEnum)Enum.ToObject(typeof(TEnum), i);
                }
                catch { }
            }

            var s = v.ToString();
            if (string.IsNullOrWhiteSpace(s)) return def;
            if (normalize != null) s = normalize(s);
            return Enum.TryParse<TEnum>(s, true, out var parsed) ? parsed : def;
        }

        static TFlags GetFlags<TFlags>(object obj, string name, Func<string, TFlags> parseFromString) where TFlags : struct
        {
            var v = GetRaw(obj, name);
            if (v == null) return parseFromString(string.Empty);

            if (v is TFlags en) return en;

            if (v is IConvertible)
            {
                try { return (TFlags)Enum.ToObject(typeof(TFlags), Convert.ToInt32(v)); }
                catch { }
            }

            return parseFromString(v.ToString());
        }

        static string FirstNonEmpty(params string[] ss)
        {
            foreach (var s in ss) if (!string.IsNullOrWhiteSpace(s)) return s;
            return null;
        }

        // -------------------- 도메인 파서 --------------------
        static string NormalizeClass(string s)
        {
            if (string.IsNullOrWhiteSpace(s)) return s;
            return s.Equals("Mythic", StringComparison.OrdinalIgnoreCase) ? "Myth" : s;
        }

        static PositionUseFlags ParseUseFlags(string csv)
        {
            if (string.IsNullOrWhiteSpace(csv))
                return PositionUseFlags.Front | PositionUseFlags.Mid1 | PositionUseFlags.Mid2 | PositionUseFlags.Back;

            PositionUseFlags acc = 0;
            foreach (var t in SplitTokens(csv))
            {
                if (t.Equals("Front", StringComparison.OrdinalIgnoreCase)) acc |= PositionUseFlags.Front;
                else if (t.Equals("Mid1", StringComparison.OrdinalIgnoreCase)) acc |= PositionUseFlags.Mid1;
                else if (t.Equals("Mid2", StringComparison.OrdinalIgnoreCase)) acc |= PositionUseFlags.Mid2;
                else if (t.Equals("Back", StringComparison.OrdinalIgnoreCase)) acc |= PositionUseFlags.Back;
            }
            return acc == 0 ? (PositionUseFlags.Front | PositionUseFlags.Mid1 | PositionUseFlags.Mid2 | PositionUseFlags.Back) : acc;
        }

        static PositionHitFlags ParseHitFlags(string csv)
        {
            if (string.IsNullOrWhiteSpace(csv))
                return PositionHitFlags.Front | PositionHitFlags.Mid1 | PositionHitFlags.Mid2 | PositionHitFlags.Mid3 | PositionHitFlags.Back;

            PositionHitFlags acc = 0;
            foreach (var t in SplitTokens(csv))
            {
                if (t.Equals("Front", StringComparison.OrdinalIgnoreCase)) acc |= PositionHitFlags.Front;
                else if (t.Equals("Mid1", StringComparison.OrdinalIgnoreCase)) acc |= PositionHitFlags.Mid1;
                else if (t.Equals("Mid2", StringComparison.OrdinalIgnoreCase)) acc |= PositionHitFlags.Mid2;
                else if (t.Equals("Mid3", StringComparison.OrdinalIgnoreCase)) acc |= PositionHitFlags.Mid3;
                else if (t.Equals("Back", StringComparison.OrdinalIgnoreCase)) acc |= PositionHitFlags.Back;
            }
            return acc == 0 ? (PositionHitFlags.Front | PositionHitFlags.Mid1 | PositionHitFlags.Mid2 | PositionHitFlags.Mid3 | PositionHitFlags.Back) : acc;
        }

        static List<string> GetTags(object obj, string name)
        {
            var v = GetRaw(obj, name);
            if (v == null) return new List<string>();

            if (v is string s)
                return SplitTokens(s).Where(x => x.Length > 0).Distinct(StringComparer.OrdinalIgnoreCase).ToList();

            var t = v.GetType();
            if (t.IsEnum)
            {
                var val = Convert.ToInt64(v);
                if (val == 0) return new List<string>();
                var labels = Enum.GetValues(t).Cast<object>()
                    .Select(x => new { x, i = Convert.ToInt64(x) })
                    .Where(e => e.i != 0 && (val & e.i) == e.i)
                    .Select(e => e.x.ToString())
                    .Distinct()
                    .ToList();
                return labels;
            }

            return new List<string> { v.ToString() };
        }

        // -------------------- Localization (리플렉션 기반) --------------------
        static readonly string[] KoCandidates = { "Ko", "KO", "ko" };
        static readonly string[] EnCandidates = { "En", "EN", "en" };
        static readonly string[] IdCandidates = { "Id", "ID", "id", "Key" };

        static Dictionary<string, (string ko, string en)> ToTextMap(IList rows)
        {
            var map = new Dictionary<string, (string, string)>(StringComparer.OrdinalIgnoreCase);
            if (rows == null) return map;

            foreach (var any in rows)
            {
                if (any == null) continue;

                var id = GetString(any, IdCandidates);
                if (string.IsNullOrWhiteSpace(id)) continue;

                var ko = GetString(any, KoCandidates);
                var en = GetString(any, EnCandidates);

                if (string.IsNullOrWhiteSpace(ko) && string.IsNullOrWhiteSpace(en))
                    continue;

                map[id] = (ko ?? "", en ?? "");
            }
            return map;
        }

        static string NormalizeLocale(string loc)
        {
            if (string.IsNullOrEmpty(loc))
                return (Application.systemLanguage == SystemLanguage.Korean) ? "ko" : "en";

            loc = loc.ToLowerInvariant();
            if (loc.StartsWith("ko")) return "ko";
            return "en";
        }

        static string ResolveText(Dictionary<string, (string ko, string en)> map, string id, string lang)
        {
            if (string.IsNullOrWhiteSpace(id)) return string.Empty;
            if (!map.TryGetValue(id, out var t)) return id; // 키 없으면 키 자체 반환
            return lang == "ko" ? t.ko : t.en;
        }

        static IEnumerable<string> SplitTokens(string s)
            => s.Split(new[] { '|', ',', ';' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(x => x.Trim());
    }
}
```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CardCsvParser.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CardCsvParser.cs.Extension)
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using SD.Gameplay.Cards.Domain;
using UnityEngine;

namespace SD.Gameplay.Cards.Infrastructure.Csv
{
    internal static class CardCsvParser
    {
        public static List<CardDataModel> Parse(TextAsset csv)
        {
            using var sr = new StringReader(csv.text);
            var rows = CsvReader.ReadAll(sr);
            if (rows.Count == 0) return new();

            var header = rows[0].Select(h => h.Trim()).ToArray();
            int Index(string name) => Array.FindIndex(header, h => string.Equals(h, name, StringComparison.OrdinalIgnoreCase));

            int idxId = Index("Id");
            int idxEnabled = Index("Enabled");
            int idxNameId = Index("NameId");
            int idxDescId = Index("DescId");
            int idxType = Index("Type");
            int idxClass = Index("Class");
            int idxRarity = Index("Rarity");
            int idxCharId = Index("CharId");
            int idxCost = Index("Cost");
            int idxTargetType = Index("TargetType");
            int idxPosUse = Index("PosUse");
            int idxPosHit = Index("PosHit");
            int idxEffects = Index("EffectsJSON");   // 문자열 JSON 컬럼
            int idxUpgradable = Index("Upgradable");
            int idxUpgradeStep = Index("UpgradeStep");
            int idxUpgradeRef = Index("UpgradeRefId");
            int idxTags = Index("Tags");

            // 최소 필수 컬럼
            var required = new[] { idxId, idxEnabled, idxType, idxClass, idxCost, idxTargetType };
            if (required.Any(i => i < 0))
                throw new InvalidDataException("CardData.csv 필수 헤더 누락(Id, Enabled, Type, Class, Cost, TargetType)");

            var list = new List<CardDataModel>();
            var ids = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            for (int r = 1; r < rows.Count; r++)
            {
                var line = rows[r];
                string Get(int i) => (i >= 0 && i < line.Length) ? line[i]?.Trim() ?? "" : "";

                try
                {
                    var id = Get(idxId);
                    if (string.IsNullOrWhiteSpace(id))
                    {
                        Debug.LogWarning($"[CardCsvParser] 행 {r + 1}: 빈 Id → 스킵");
                        continue;
                    }
                    if (!ids.Add(id))
                    {
                        Debug.LogWarning($"[CardCsvParser] 행 {r + 1}: 중복 Id: {id} → 스킵");
                        continue;
                    }

                    bool enabled = ParseBool(Get(idxEnabled));
                    if (!enabled) continue; // 비활성은 스킵

                    var nameId = Get(idxNameId);
                    var descId = Get(idxDescId);
                    var type = ParseEnum<CardType>(Get(idxType));
                    var @class = ParseEnum<CardClass>(Get(idxClass));
                    var rarity = ParseEnumSafe<CardRarity>(Get(idxRarity), CardRarity.Common);
                    var charId = string.IsNullOrEmpty(Get(idxCharId)) ? "Public" : Get(idxCharId);
                    int cost = ParseInt(Get(idxCost), 0);
                    var target = ParseEnum<TargetType>(Get(idxTargetType));
                    var posUse = ParseFlags<PositionUseFlags>(Get(idxPosUse));
                    var posHit = ParseFlags<PositionHitFlags>(Get(idxPosHit));
                    var effectsJson = Get(idxEffects); // 문자열 그대로 저장
                    bool upgradable = ParseBool(Get(idxUpgradable));
                    int upgradeStep = ParseInt(Get(idxUpgradeStep), 0);
                    var upgradeRefId = Get(idxUpgradeRef);
                    var tags = ParseFlags<CardTagFlags>(Get(idxTags));

                    // --- 생성자 사용 금지: 기본 생성 + 멤버 세팅(유연) ---
                    var model = Activator.CreateInstance<CardDataModel>();

                    // 문자열/스칼라
                    SetMember(model, "Id", id);
                    SetMember(model, "Enabled", enabled);
                    SetMember(model, "NameId", nameId);
                    SetMember(model, "DescId", descId);
                    SetMember(model, "Class", @class);
                    SetMember(model, "Type", type);
                    SetMember(model, "Rarity", rarity);
                    SetMember(model, "CharId", charId);
                    SetMember(model, "Cost", cost);
                    SetMember(model, "TargetType", target);
                    SetMember(model, "PosUse", posUse);
                    SetMember(model, "PosHit", posHit);
                    SetMember(model, "Upgradable", upgradable);
                    SetMember(model, "UpgradeStep", upgradeStep);
                    SetMember(model, "UpgradeRefId", upgradeRefId);
                    SetMember(model, "Tags", tags);

                    // 이펙트: 우선 문자열 JSON 컬럼 우선 (CardFactory에서 파싱)
                    if (!string.IsNullOrWhiteSpace(effectsJson))
                    {
                        // 모델에 EffectsJSON(string)이 있으면 그쪽으로 저장
                        if (!SetMember(model, "EffectsJSON", effectsJson))
                        {
                            // (옵션) 모델에 Effects(List<EffectSpec>)가 있다면 주석 해제하여 즉시 파싱 저장
                            // try
                            // {
                            //     var specs = SD.Gameplay.Cards.Domain.Effects.EffectJsonParser.Parse(effectsJson);
                            //     SetMember(model, "Effects", specs);
                            // }
                            // catch { /* 파싱 실패 무시, 팩토리에서 다시 시도 */ }
                        }
                    }

                    list.Add(model);
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[CardCsvParser] 행 {r + 1} 파싱 실패: {ex.Message}");
                }
            }

            Debug.Log($"[CardCsvParser] 로드 완료: {list.Count}개");
            return list;
        }

        // ----------------- 파싱 유틸 -----------------
        static bool ParseBool(string s) =>
            !string.IsNullOrEmpty(s) && (s.Equals("true", StringComparison.OrdinalIgnoreCase) || s == "1" || s.Equals("yes", StringComparison.OrdinalIgnoreCase));

        static int ParseInt(string s, int def) => int.TryParse(s, out var v) ? v : def;

        static T ParseEnum<T>(string s) where T : struct =>
            Enum.TryParse<T>(s, true, out var v) ? v : throw new InvalidDataException($"Enum 파싱 실패: {typeof(T).Name}='{s}'");

        static T ParseEnumSafe<T>(string s, T def) where T : struct =>
            Enum.TryParse<T>(s, true, out var v) ? v : def;

        static U ParseFlags<U>(string s) where U : struct
        {
            if (string.IsNullOrWhiteSpace(s)) return default;
            ulong acc = 0;
            foreach (var token in s.Split('|'))
            {
                var t = token.Trim();
                if (string.IsNullOrEmpty(t)) continue;
                if (!Enum.TryParse<U>(t, true, out var part))
                    throw new InvalidDataException($"Flags 파싱 실패: {typeof(U).Name}='{t}'");
                acc |= Convert.ToUInt64(part);
            }
            return (U)Enum.ToObject(typeof(U), acc);
        }

        // ----------------- 리플렉션 세터 -----------------
        static readonly BindingFlags _bf = BindingFlags.Instance | BindingFlags.Public | BindingFlags.IgnoreCase;

        /// <summary>
        /// model의 프로퍼티/필드 중 name과 일치하는 멤버를 찾아 값을 대입. 없으면 false.
        /// enum/기본형/참조형을 모두 처리(타입 호환 시).
        /// </summary>
        static bool SetMember(object model, string name, object value)
        {
            var t = model.GetType();

            // 프로퍼티 우선
            var p = t.GetProperty(name, _bf);
            if (p != null && p.CanWrite)
            {
                var ok = TryConvert(value, p.PropertyType, out var boxed);
                if (ok)
                {
                    try { p.SetValue(model, boxed); return true; } catch { }
                }
            }

            // 필드
            var f = t.GetField(name, _bf);
            if (f != null)
            {
                var ok = TryConvert(value, f.FieldType, out var boxed);
                if (ok)
                {
                    try { f.SetValue(model, boxed); return true; } catch { }
                }
            }

            return false;
        }

        static bool TryConvert(object src, Type dst, out object boxed)
        {
            boxed = null;
            if (src == null)
            {
                if (!dst.IsValueType || Nullable.GetUnderlyingType(dst) != null) { boxed = null; return true; }
                return false;
            }

            var sType = src.GetType();
            if (dst.IsAssignableFrom(sType)) { boxed = src; return true; }

            // enum ← 숫자/문자열
            if (dst.IsEnum)
            {
                try
                {
                    if (src is string ss && Enum.TryParse(dst, ss, true, out var e1)) { boxed = e1; return true; }
                    var i = Convert.ToInt64(src);
                    boxed = Enum.ToObject(dst, i);
                    return true;
                }
                catch { return false; }
            }

            // Nullable<T>
            var u = Nullable.GetUnderlyingType(dst);
            if (u != null)
            {
                if (src is string str && string.IsNullOrWhiteSpace(str)) { boxed = null; return true; }
                return TryConvert(src, u, out boxed);
            }

            try
            {
                // 숫자/기본형 변환 시도
                boxed = Convert.ChangeType(src, dst);
                return true;
            }
            catch
            {
                // List<T> 등은 컬렉션 그대로 허용 (타입 호환 시)
                if (dst.IsGenericType && src is System.Collections.IEnumerable e &&
                    typeof(System.Collections.IEnumerable).IsAssignableFrom(dst))
                {
                    boxed = src; return true;
                }
                return false;
            }
        }
    }
}
```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CardCsvRow.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CardCsvRow.cs.Extension)
namespace SD.Gameplay.Cards.Infrastructure.Csv
{
    internal struct CardCsvRow
    {
        public string Id, Enabled, NameId, DescId, Type, Class, Rarity, CharId, Cost,
                      TargetType, PosUse, PosHit, EffectsJSON, Upgradable, UpgradeStep, UpgradeRefId, Tags;
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CsvCardRepository.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CsvCardRepository.cs.Extension)
using System.Collections.Generic;
using System.Linq;
using SD.Gameplay.Cards.Domain;
using UnityEngine;

namespace SD.Gameplay.Cards.Infrastructure.Csv
{
    public sealed class CsvCardRepository : ICardRepository
    {
        private readonly Dictionary<string, CardDataModel> _byId;

        public CsvCardRepository(TextAsset cardDataCsv)
        {
            var list = CardCsvParser.Parse(cardDataCsv);
            _byId = new Dictionary<string, CardDataModel>(list.Count, System.StringComparer.OrdinalIgnoreCase);
            foreach (var c in list) _byId[c.Id] = c;
        }

        public bool TryGet(string id, out CardDataModel card) => _byId.TryGetValue(id, out card);
        public IEnumerable<CardDataModel> All => _byId.Values;
        public int Count => _byId.Count;
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CsvReader.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Csv\CsvReader.cs.Extension)
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace SD.Gameplay.Cards.Infrastructure.Csv
{
    internal static class CsvReader
    {
        // RFC4180 호환 간단판: 따옴표로 감싼 필드의 콤마 허용, "" → " 이스케이프 처리
        public static List<string[]> ReadAll(TextReader reader, char delimiter = ',')
        {
            var result = new List<string[]>();
            var row = new List<string>();
            var sb = new StringBuilder();
            bool inQuotes = false;

            while (true)
            {
                int c = reader.Read();
                if (c == -1)
                {
                    if (inQuotes) throw new InvalidDataException("CSV: 문자열 닫힘 누락");
                    if (sb.Length > 0 || row.Count > 0) { row.Add(sb.ToString()); result.Add(row.ToArray()); }
                    break;
                }

                char ch = (char)c;
                if (inQuotes)
                {
                    if (ch == '"')
                    {
                        int next = reader.Peek();
                        if (next == '"') { reader.Read(); sb.Append('"'); } // 이스케이프
                        else inQuotes = false;
                    }
                    else sb.Append(ch);
                }
                else
                {
                    if (ch == '"') inQuotes = true;
                    else if (ch == delimiter) { row.Add(sb.ToString()); sb.Clear(); }
                    else if (ch == '\n')
                    {
                        // CRLF/ LF 처리
                        if (sb.Length > 0 || row.Count > 0) { row.Add(sb.ToString()); sb.Clear(); result.Add(row.ToArray()); row.Clear(); }
                    }
                    else if (ch == '\r') { /* ignore */ }
                    else sb.Append(ch);
                }
            }

            return result;
        }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Editor\CardDataValidateMenu.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Editor\CardDataValidateMenu.cs.Extension)
#if UNITY_EDITOR
using System.Linq;
using SD.DataTable;
using SD.Gameplay.Cards.Infrastructure.Csv; // CsvCardRepository(TextAsset csv) 사용
using UnityEditor;
using UnityEngine;

public static class CardDataValidateMenu
{
    [MenuItem("SD/Data/Validate CardData.csv")]
    public static void Validate()
    {
        var config = FindConfigAsset();
        if (config == null || config.Tables == null || config.Tables.Count == 0)
        {
            Debug.LogError("[Validate] DataTableConfig을 찾지 못했거나 테이블이 비어있습니다. Tools > DataTables > Sync All 실행/Config 연결을 확인하세요.");
            return;
        }

        // 1) CardData 항목 하나를 찾는다
        var cardEntry = config.Tables.FirstOrDefault(
            t => string.Equals(t.Id, "CardData", System.StringComparison.OrdinalIgnoreCase));

        if (cardEntry.Csv == null)
        {
            Debug.LogError("[Validate] 'CardData' 항목을 찾지 못했거나 CSV가 비어있습니다.");
            return;
        }

        // 2) CsvCardRepository는 TextAsset 하나를 받으므로 그걸 넘긴다
        var repo = new CsvCardRepository(cardEntry.Csv); // ← 핵심 수정
        var ids = repo.All.Select(c => c.Id).ToList();

        if (ids.Count == 0)
        {
            Debug.LogWarning("[Validate] CardData가 0개로 로드되었습니다. Enabled/RowTypeName/CSV 내용을 확인하세요.");
        }
        else
        {
            Debug.Log($"CardData 유효성 OK. 총 {ids.Count}개\n- 상위 10개: {string.Join(", ", ids.Take(10))}");
        }
    }

    /// 프로젝트 전체에서 DataTableConfig를 찾아 테이블 수가 가장 많은 것을 선택
    private static DataTableConfig FindConfigAsset()
    {
        var guids = AssetDatabase.FindAssets("t:DataTableConfig");
        var assets = guids
            .Select(g => AssetDatabase.LoadAssetAtPath<DataTableConfig>(AssetDatabase.GUIDToAssetPath(g)))
            .Where(a => a != null)
            .ToList();

        if (assets.Count == 0) return null;
        if (assets.Count == 1) return assets[0];

        var chosen = assets.OrderByDescending(a => a.Tables?.Count ?? 0).First();
        var info = string.Join("\n - ", assets.Select(a => $"{AssetDatabase.GetAssetPath(a)} (Tables={a.Tables?.Count ?? 0})"));
        Debug.LogWarning($"[Validate] DataTableConfig가 여러 개입니다. 테이블이 가장 많은 에셋을 선택합니다.\n - 후보:\n - {info}\n - 선택: {AssetDatabase.GetAssetPath(chosen)}");
        return chosen;
    }
}
#endif
```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Editor\SD.Gameplay.Cards.Infrastructure.Editor.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\Editor\SD.Gameplay.Cards.Infrastructure.Editor.asmdef.Extension)
{
  "name": "SD.Gameplay.Cards.Infrastructure.Editor",
  "references": [
    "SD.Gameplay.Cards.Domain",
    "SD.Gameplay.Cards.Infrastructure",
    "SD.DataTable.Runtime",
    "UnityEditor"
  ],
  "includePlatforms": ["Editor"],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\GameBootstrap.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\GameBootstrap.cs.Extension)
using System.Collections.Generic;
using UnityEngine;
using SD.Gameplay.Cards.Domain;

namespace SD.Gameplay.Cards.Infrastructure
{
    [DefaultExecutionOrder(-100)]
    public sealed class GameBootstrap : MonoBehaviour
    {
        [SerializeField] private string _locale = "ko";
        [SerializeField] private CardCatalog _catalog;

        private void Awake()
        {
            // TableRegistry는 풀네임으로 (using SD.DataTable 불필요)
            var rowsCard = global::SD.DataTable.TableRegistry.Get("CardData");
            var rowsName = global::SD.DataTable.TableRegistry.Get("CardName");
            var rowsDesc = global::SD.DataTable.TableRegistry.Get("CardDesc");

            rowsCard ??= System.Array.Empty<object>();
            rowsName ??= System.Array.Empty<object>();
            rowsDesc ??= System.Array.Empty<object>();

            var cards = CardFactory.BuildAll(rowsCard, rowsName, rowsDesc, _locale);

            if (_catalog == null)
            {
                var go = new GameObject("CardCatalog");
                _catalog = go.AddComponent<CardCatalog>();
            }
            _catalog.Set(cards);

            Debug.Log("[Bootstrap] CardCatalog ready: " + cards.Count + " cards");
        }
    }
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\SD.Gameplay.Cards.Infrastructure.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Infrastructure\SD.Gameplay.Cards.Infrastructure.asmdef.Extension)
{
  "name": "SD.Gameplay.Cards.Infrastructure",
  "references": [
    "SD.Gameplay.Cards.Domain",
    "SD.DataTable.Runtime"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Gameplay\Cards\Presentation\SD.Gameplay.Cards.Presentation.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Gameplay\Cards\Presentation\SD.Gameplay.Cards.Presentation.asmdef.Extension)
{
  "name": "SD.Gameplay.Cards.Presentation",
  "references": [
    "SD.Gameplay.Cards.Domain",
    "SD.Core.Presentation"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Tools\Editor\AsmdefBootstrapper.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Tools\Editor\AsmdefBootstrapper.cs.Extension)
// File: Assets/SDProject/Scripts/Tools/Editor/AsmdefBootstrapper.cs
// 목적: 정식 구조용 asmdef 일괄 생성 (idempotent)
// 메뉴: SD/Bootstrap/Create asmdefs
#if UNITY_EDITOR
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace SD.Tools.Editor
{
    internal static class AsmdefBootstrapper
    {
        private const bool OverwriteExisting = true;

        // 경로 유틸
        private static string P(params string[] parts) => string.Join("/", parts);

        // 현재 스크립트의 경로를 기반으로 루트(Assets/***까지)를 자동 추출
        // 예: Assets/SDProject/Scripts/Tools/Editor/AsmdefBootstrapper.cs -> Assets/SDProject
        private static string DetectProjectRoot()
        {
            try
            {
                // 이 클래스 소스 에셋 검색
                var guids = AssetDatabase.FindAssets("AsmdefBootstrapper t:Script");
                foreach (var guid in guids)
                {
                    var path = AssetDatabase.GUIDToAssetPath(guid);
                    if (!path.EndsWith("AsmdefBootstrapper.cs", StringComparison.OrdinalIgnoreCase))
                        continue;

                    var idx = path.IndexOf("/Scripts/", StringComparison.Ordinal);
                    if (idx > 0)
                    {
                        var root = path.Substring(0, idx); // "Assets/SDProject"
                        if (root.StartsWith("Assets/", StringComparison.Ordinal))
                            return root;
                    }
                }
            }
            catch { /* no-op */ }

            // 폴백: 흔한 루트 후보
            var candidates = new[] { "Assets/SDProject", "Assets/_Project" };
            foreach (var c in candidates)
            {
                if (AssetDatabase.IsValidFolder(c))
                    return c;
            }

            throw new InvalidOperationException("프로젝트 루트를 찾을 수 없습니다. 'Assets/SDProject' 또는 'Assets/_Project' 중 하나를 생성하거나, 스크립트를 'Assets/<Root>/Scripts/.../AsmdefBootstrapper.cs'에 두세요.");
        }

        // asmdef JSON 모델
        [Serializable]
        private class AsmdefJson
        {
            public string name;
            public string[] references = Array.Empty<string>();
            public string[] includePlatforms = Array.Empty<string>();
            public string[] excludePlatforms = Array.Empty<string>();
            public bool allowUnsafeCode = false;
            public bool autoReferenced = true;
            public bool overrideReferences = false;
            public string[] precompiledReferences = Array.Empty<string>();
            public string[] defineConstraints = Array.Empty<string>();
            public bool noEngineReferences = false;
            public string[] optionalUnityReferences = Array.Empty<string>(); // tests
        }

        private class AsmdefSpec
        {
            public string Name;
            public string RelFolder;              // 루트(base)/ 하위 상대 경로 ("Scripts/Core/Domain" 등)
            public string[] References;
            public bool EditorOnly = false;
            public bool IsTestAssembly = false;
            public bool NoEngineRefs = false;
            public bool AutoReferenced = true;
        }

        // ====== 정의 목록 ======
        // 주의: 폴더는 "루트/RelFolder"로 생성됨. 루트는 DetectProjectRoot()로 자동 결정.
        private static readonly List<AsmdefSpec> _specs = new()
        {
            // Core
            new AsmdefSpec { Name = "SD.Core.Domain",          RelFolder = "Scripts/Core/Domain",          References = Array.Empty<string>(), NoEngineRefs = false },
            new AsmdefSpec { Name = "SD.Core.Infrastructure",  RelFolder = "Scripts/Core/Infrastructure",  References = new [] { "SD.Core.Domain" } },
            new AsmdefSpec { Name = "SD.Core.Presentation",    RelFolder = "Scripts/Core/Presentation",    References = new [] { "SD.Core.Domain", "SD.Core.Infrastructure", "Unity.TextMeshPro" } },

            // Gameplay.Cards
            new AsmdefSpec { Name = "SD.Gameplay.Cards.Domain",         RelFolder = "Scripts/Gameplay/Cards/Domain",         References = new [] { "SD.Core.Domain" } },
            new AsmdefSpec { Name = "SD.Gameplay.Cards.Infrastructure", RelFolder = "Scripts/Gameplay/Cards/Infrastructure", References = new [] { "SD.Gameplay.Cards.Domain", "SD.Core.Infrastructure" } },
            new AsmdefSpec { Name = "SD.Gameplay.Cards.Presentation",   RelFolder = "Scripts/Gameplay/Cards/Presentation",   References = new [] { "SD.Gameplay.Cards.Domain", "SD.Core.Presentation" } },

            // Gameplay.Battle
            new AsmdefSpec { Name = "SD.Gameplay.Battle.Domain",         RelFolder = "Scripts/Gameplay/Battle/Domain",         References = new [] { "SD.Core.Domain", "SD.Gameplay.Cards.Domain" } },
            new AsmdefSpec { Name = "SD.Gameplay.Battle.Infrastructure", RelFolder = "Scripts/Gameplay/Battle/Infrastructure", References = new [] { "SD.Gameplay.Battle.Domain", "SD.Core.Infrastructure" } },
            new AsmdefSpec { Name = "SD.Gameplay.Battle.Presentation",   RelFolder = "Scripts/Gameplay/Battle/Presentation",   References = new [] { "SD.Gameplay.Battle.Domain", "SD.Core.Presentation" } },

            // DataTables
            new AsmdefSpec { Name = "SD.DataTables.Runtime", RelFolder = "Scripts/DataTable/Runtime", References = new [] { "SD.Core.Domain", "Unity.Addressables" } },
            new AsmdefSpec { Name = "SD.DataTables.Editor",  RelFolder = "Scripts/DataTable/Editor",  References = new [] { "SD.DataTables.Runtime" }, EditorOnly = true },

            // UI / Tools
            new AsmdefSpec { Name = "SD.UI.Common",  RelFolder = "Scripts/UI/Common",  References = new [] { "SD.Core.Presentation", "Unity.TextMeshPro" } },
            new AsmdefSpec { Name = "SD.UI.Editor",  RelFolder = "Scripts/UI/Editor",  References = new [] { "SD.UI.Common" }, EditorOnly = true },
            new AsmdefSpec { Name = "SD.Tools.Editor", RelFolder = "Scripts/Tools/Editor", References = Array.Empty<string>(), EditorOnly = true },

            // Tests
            new AsmdefSpec {
                Name = "SD.Tests.EditMode",
                RelFolder = "Scripts/Core/Tests",
                References = new [] { "SD.Core.Domain", "SD.Core.Infrastructure" },
                EditorOnly = true, IsTestAssembly = true
            },
            new AsmdefSpec {
                Name = "SD.Gameplay.Tests",
                RelFolder = "Scripts/Gameplay/Battle/Tests",
                References = new [] { "SD.Gameplay.Battle.Domain", "SD.Gameplay.Battle.Infrastructure", "SD.Core.Infrastructure", "SD.Gameplay.Cards.Domain" },
                EditorOnly = true, IsTestAssembly = true
            },
        };

        [MenuItem("SD/Bootstrap/Create asmdefs", priority = 10)]
        public static void CreateAsmdefs()
        {
            var baseRoot = DetectProjectRoot(); // ex) "Assets/SDProject"
            try
            {
                int created = 0, skipped = 0, overwritten = 0;

                foreach (var spec in _specs)
                {
                    var fullFolder = P(baseRoot, spec.RelFolder);
                    EnsureFolder(fullFolder);

                    var asmdefPath = P(fullFolder, $"{spec.Name}.asmdef");
                    var json = BuildJson(spec);

                    if (File.Exists(asmdefPath))
                    {
                        if (!OverwriteExisting)
                        {
                            skipped++;
                            continue;
                        }
                        var old = File.ReadAllText(asmdefPath, Encoding.UTF8);
                        if (old == json)
                        {
                            skipped++;
                            continue;
                        }
                        File.WriteAllText(asmdefPath, json, Encoding.UTF8);
                        overwritten++;
                    }
                    else
                    {
                        File.WriteAllText(asmdefPath, json, Encoding.UTF8);
                        created++;
                    }
                }

                AssetDatabase.Refresh();
                Debug.Log($"[AsmdefBootstrapper] Root='{baseRoot}' Done. created={created}, overwritten={overwritten}, skipped={skipped}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AsmdefBootstrapper] ERROR: {ex.Message}\n{ex.StackTrace}");
                throw;
            }
        }

        private static void EnsureFolder(string folderPath)
        {
            var parts = folderPath.Split(new[] { '/', '\\' }, StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length == 0 || parts[0] != "Assets")
                throw new InvalidOperationException($"경로는 'Assets/..'로 시작해야 합니다: {folderPath}");

            var current = "Assets";
            for (int i = 1; i < parts.Length; i++)
            {
                var next = P(current, parts[i]);
                if (!AssetDatabase.IsValidFolder(next))
                    AssetDatabase.CreateFolder(current, parts[i]);
                current = next;
            }
        }

        private static string BuildJson(AsmdefSpec spec)
        {
            var data = new AsmdefJson
            {
                name = spec.Name,
                references = spec.References?.Distinct().ToArray() ?? Array.Empty<string>(),
                includePlatforms = spec.EditorOnly ? new[] { "Editor" } : Array.Empty<string>(),
                excludePlatforms = Array.Empty<string>(),
                allowUnsafeCode = false,
                autoReferenced = spec.AutoReferenced,
                overrideReferences = false,
                precompiledReferences = Array.Empty<string>(),
                defineConstraints = Array.Empty<string>(),
                noEngineReferences = spec.NoEngineRefs,
                optionalUnityReferences = spec.IsTestAssembly ? new[] { "TestAssemblies" } : Array.Empty<string>()
            };

            var sb = new StringBuilder();
            void Arr(string key, IEnumerable<string> arr)
            {
                var list = arr?.ToArray() ?? Array.Empty<string>();
                sb.Append($"  \"{key}\": [");
                if (list.Length > 0)
                {
                    sb.Append("\n");
                    for (int i = 0; i < list.Length; i++)
                    {
                        sb.Append($"    \"{list[i]}\"");
                        if (i < list.Length - 1) sb.Append(",");
                        sb.Append("\n");
                    }
                    sb.Append("  ]");
                }
                else sb.Append("]");
            }

            sb.Append("{\n");
            sb.AppendFormat("  \"name\": \"{0}\",\n", Escape(data.name));
            Arr("references", data.references); sb.Append(",\n");
            Arr("includePlatforms", data.includePlatforms); sb.Append(",\n");
            Arr("excludePlatforms", data.excludePlatforms); sb.Append(",\n");
            sb.AppendFormat("  \"allowUnsafeCode\": {0},\n", data.allowUnsafeCode.ToString().ToLower());
            sb.AppendFormat("  \"autoReferenced\": {0},\n", data.autoReferenced.ToString().ToLower());
            sb.AppendFormat("  \"overrideReferences\": {0},\n", data.overrideReferences.ToString().ToLower());
            Arr("precompiledReferences", data.precompiledReferences); sb.Append(",\n");
            Arr("defineConstraints", data.defineConstraints); sb.Append(",\n");
            sb.AppendFormat("  \"noEngineReferences\": {0}", data.noEngineReferences.ToString().ToLower());
            if (data.optionalUnityReferences != null && data.optionalUnityReferences.Length > 0)
            {
                sb.Append(",\n");
                Arr("optionalUnityReferences", data.optionalUnityReferences);
            }
            sb.Append("\n}\n");
            return sb.ToString();
        }

        private static string Escape(string s) => s?.Replace("\\", "\\\\").Replace("\"", "\\\"") ?? "";
    }
}
#endif

```

## Assets\SDProject\Scripts\Tools\Editor\FolderTreeSnapshot.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Tools\Editor\FolderTreeSnapshot.cs.Extension)
#if UNITY_EDITOR
using System;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace SD.Tools.Editor
{
    public static class FolderTreeSnapshot
    {
        private const string DefaultRoot = "Assets/SDProject";
        private const string DefaultOut = "Assets/SDProject/Docs/folder-tree.txt";
        private const string PrefKey_Root = "SD.Status.FolderRoot";
        private const string PrefKey_Out = "SD.Status.FolderTreePath";

        [MenuItem("Tools/Project/Generate Folder Tree", priority = 2)]
        public static void GenerateFolderTreeFile()
        {
            var root = EditorPrefs.GetString(PrefKey_Root, DefaultRoot);
            var outRel = EditorPrefs.GetString(PrefKey_Out, DefaultOut);
            WriteTree(root, outRel);
        }

        [MenuItem("Tools/Project/Generate Status + Folder Tree", priority = 0)]
        public static void GenerateStatusAndTree()
        {
            try { StatusFileGenerator.Generate(); }
            catch (Exception ex) { Debug.LogError($"[Status] Generate failed: {ex.Message}"); }
            GenerateFolderTreeFile();
        }

        [PreferenceItem("SDProject")]
        public static void Prefs()
        {
            EditorGUILayout.Space(8);
            EditorGUILayout.LabelField("Folder Tree Snapshot", EditorStyles.boldLabel);

            var root = EditorPrefs.GetString(PrefKey_Root, DefaultRoot);
            var outRel = EditorPrefs.GetString(PrefKey_Out, DefaultOut);

            EditorGUILayout.BeginHorizontal();
            var nextRoot = EditorGUILayout.TextField("Root Folder", root);
            if (GUILayout.Button("Reset", GUILayout.Width(70))) nextRoot = DefaultRoot;
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            var nextOut = EditorGUILayout.TextField("Output Path", outRel);
            if (GUILayout.Button("Reset", GUILayout.Width(70))) nextOut = DefaultOut;
            EditorGUILayout.EndHorizontal();

            if (nextRoot != root) EditorPrefs.SetString(PrefKey_Root, nextRoot);
            if (nextOut != outRel) EditorPrefs.SetString(PrefKey_Out, nextOut);

            if (GUILayout.Button("Generate Folder Tree Now")) GenerateFolderTreeFile();
        }

        private static void WriteTree(string rootFolder, string outRelPath)
        {
            if (!AssetDatabase.IsValidFolder(rootFolder))
            {
                Debug.LogWarning($"[folder-tree] Root folder not found: {rootFolder}");
                return;
            }

            var outFull = Path.GetFullPath(outRelPath);
            Directory.CreateDirectory(Path.GetDirectoryName(outFull)!);

            var sb = new StringBuilder();
            sb.AppendLine(rootFolder + "/");
            Recurse(rootFolder, 1, sb);

            File.WriteAllText(outFull, sb.ToString(), new UTF8Encoding(false));
            File.WriteAllText(outFull, sb.ToString(), new UTF8Encoding(false));

            // ★ Unity에 강제 반영
            AssetDatabase.ImportAsset(outRelPath, ImportAssetOptions.ForceSynchronousImport | ImportAssetOptions.ForceUpdate);
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh(ImportAssetOptions.ForceUpdate);

            // ★ 풀 경로 로그
            Debug.Log($"[folder-tree] Wrote (rel): {outRelPath}");
            Debug.Log($"[folder-tree] Wrote (abs): {outFull}");
        }

        private static void Recurse(string folder, int depth, StringBuilder sb, int maxDepth = 12)
        {
            if (depth > maxDepth) return;
            string indent = new string(' ', depth * 2);

            foreach (var sf in AssetDatabase.GetSubFolders(folder).OrderBy(p => p, StringComparer.OrdinalIgnoreCase))
            {
                sb.AppendLine($"{indent}{Path.GetFileName(sf)}/");
                Recurse(sf, depth + 1, sb, maxDepth);
            }

            var files = AssetDatabase.FindAssets("", new[] { folder })
                        .Select(AssetDatabase.GUIDToAssetPath)
                        .Where(p => !AssetDatabase.IsValidFolder(p))
                        .Where(p => p.EndsWith(".asmdef", StringComparison.OrdinalIgnoreCase)
                                 || p.EndsWith(".asset", StringComparison.OrdinalIgnoreCase)
                                 || p.EndsWith(".csv", StringComparison.OrdinalIgnoreCase)
                                 || p.EndsWith(".xlsx", StringComparison.OrdinalIgnoreCase)
                                 || p.EndsWith(".cs", StringComparison.OrdinalIgnoreCase))
                        .OrderBy(p => p, StringComparer.OrdinalIgnoreCase);

            foreach (var f in files) sb.AppendLine($"{indent}- {Path.GetFileName(f)}");
        }
    }
}
#endif

```

## Assets\SDProject\Scripts\Tools\Editor\SD.Tools.Editor.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Tools\Editor\SD.Tools.Editor.asmdef.Extension)
{
  "name": "SD.Tools.Editor",
  "references": [
    "SD.DataTable.Runtime",
    "SD.DataTable.Editor"
  ],
  "includePlatforms": ["Editor"],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\Tools\Editor\StatusFileGenerator.cs
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\Tools\Editor\StatusFileGenerator.cs.Extension)
#if UNITY_EDITOR
using System;
using System.IO;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace SD.Tools.Editor
{
    /// <summary>
    /// 프로젝트 상태 요약 Markdown 파일 생성기.
    /// FolderTreeSnapshot에서 호출하는 Generate()를 제공해
    /// "Generate Status + Folder Tree" 메뉴가 정상 동작하도록 한다.
    /// </summary>
    public static class StatusFileGenerator
    {
        private const string DefaultOut = "Assets/SDProject/Docs/SDProject_Status.md";

        [MenuItem("Tools/Project/Generate Status File", priority = 1)]
        public static void GenerateMenu()
        {
            Generate(); // 메뉴에서 호출 시 동일 로직 사용
        }

        /// <summary>
        /// FolderTreeSnapshot.GenerateStatusAndTree()가 호출하는 API.
        /// 프로젝트 요약을 간단히 기록한다(의존성 최소화).
        /// </summary>
        public static void Generate()
        {
            try
            {
                WriteStatus(DefaultOut);
                Debug.Log($"[Status] Wrote: {DefaultOut}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[Status] Generate failed: {ex.Message}");
            }
        }

        private static void WriteStatus(string outRelPath)
        {
            var outFull = Path.GetFullPath(outRelPath);
            Directory.CreateDirectory(Path.GetDirectoryName(outFull)!);

            var sb = new StringBuilder();
            sb.AppendLine("# SDProject - Status");
            sb.AppendLine();
            sb.AppendLine($"- Generated: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine($"- Unity: {Application.unityVersion}");
#if UNITY_EDITOR
            sb.AppendLine($"- Platform: {EditorUserBuildSettings.activeBuildTarget}");
#endif
            sb.AppendLine();

            // 최소 정보만 남김 (강한 의존성 없이 항상 성공하게)
            sb.AppendLine("## Notes");
            sb.AppendLine("- 이 파일은 Tools ▸ Project ▸ Generate Status File 혹은");
            sb.AppendLine("- Tools ▸ Project ▸ Generate Status + Folder Tree 실행 시 생성/갱신됩니다.");
            sb.AppendLine();

            File.WriteAllText(outFull, sb.ToString(), new UTF8Encoding(false));

            // Unity에 반영
            AssetDatabase.ImportAsset(outRelPath, ImportAssetOptions.ForceSynchronousImport | ImportAssetOptions.ForceUpdate);
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh(ImportAssetOptions.ForceUpdate);
        }
    }
}
#endif
```

## Assets\SDProject\Scripts\UI\Common\SD.UI.Common.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\UI\Common\SD.UI.Common.asmdef.Extension)
{
  "name": "SD.UI.Common",
  "rootNamespace": "SD.UI.Common",
  "references": [
    "SD.Gameplay.Cards.Domain"
  ],
  "includePlatforms": [],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "versionDefines": [],
  "noEngineReferences": false
}

```

## Assets\SDProject\Scripts\UI\Editor\SD.UI.Editor.asmdef
`$(Get-CodeLang D:\SD\SDProject\Assets\SDProject\Scripts\UI\Editor\SD.UI.Editor.asmdef.Extension)
{
  "name": "SD.UI.Editor",
  "references": [
    "SD.UI.Common"
  ],
  "includePlatforms": [
    "Editor"
  ],
  "excludePlatforms": [],
  "allowUnsafeCode": false,
  "autoReferenced": true,
  "overrideReferences": false,
  "precompiledReferences": [],
  "defineConstraints": [],
  "noEngineReferences": false
}

```

